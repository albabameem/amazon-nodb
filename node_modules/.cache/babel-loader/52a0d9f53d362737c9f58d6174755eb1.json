{"ast":null,"code":"/**\n * TODO: These methods can probably be combined somehow\n * Parse HTML tags & HTML Characters\n */\nexport default class HTMLParser {\n  /**\n   * Type HTML tags & HTML Characters\n   * @param {string} curString Current string\n   * @param {number} curStrPos Position in current string\n   * @param {Typed} self instance of Typed\n   * @returns {number} a new string position\n   * @private\n   */\n  typeHtmlChars(curString, curStrPos, self) {\n    if (self.contentType !== 'html') return curStrPos;\n    const curChar = curString.substr(curStrPos).charAt(0);\n\n    if (curChar === '<' || curChar === '&') {\n      let endTag = '';\n\n      if (curChar === '<') {\n        endTag = '>';\n      } else {\n        endTag = ';';\n      }\n\n      while (curString.substr(curStrPos + 1).charAt(0) !== endTag) {\n        curStrPos++;\n\n        if (curStrPos + 1 > curString.length) {\n          break;\n        }\n      }\n\n      curStrPos++;\n    }\n\n    return curStrPos;\n  }\n  /**\n   * Backspace HTML tags and HTML Characters\n   * @param {string} curString Current string\n   * @param {number} curStrPos Position in current string\n   * @param {Typed} self instance of Typed\n   * @returns {number} a new string position\n   * @private\n   */\n\n\n  backSpaceHtmlChars(curString, curStrPos, self) {\n    if (self.contentType !== 'html') return curStrPos;\n    const curChar = curString.substr(curStrPos).charAt(0);\n\n    if (curChar === '>' || curChar === ';') {\n      let endTag = '';\n\n      if (curChar === '>') {\n        endTag = '<';\n      } else {\n        endTag = '&';\n      }\n\n      while (curString.substr(curStrPos - 1).charAt(0) !== endTag) {\n        curStrPos--;\n\n        if (curStrPos < 0) {\n          break;\n        }\n      }\n\n      curStrPos--;\n    }\n\n    return curStrPos;\n  }\n\n}\nexport let htmlParser = new HTMLParser();","map":{"version":3,"sources":["/Users/albab/bookapro/amazon/src/assets/vendor/typed.js/src/html-parser.js"],"names":["HTMLParser","typeHtmlChars","curString","curStrPos","self","contentType","curChar","substr","charAt","endTag","length","backSpaceHtmlChars","htmlParser"],"mappings":"AAAA;AACA;AACA;AACA;AAEA,eAAe,MAAMA,UAAN,CAAiB;AAC9B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AAEEC,EAAAA,aAAa,CAACC,SAAD,EAAYC,SAAZ,EAAuBC,IAAvB,EAA6B;AACxC,QAAIA,IAAI,CAACC,WAAL,KAAqB,MAAzB,EAAiC,OAAOF,SAAP;AACjC,UAAMG,OAAO,GAAGJ,SAAS,CAACK,MAAV,CAAiBJ,SAAjB,EAA4BK,MAA5B,CAAmC,CAAnC,CAAhB;;AACA,QAAIF,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;AACtC,UAAIG,MAAM,GAAG,EAAb;;AACA,UAAIH,OAAO,KAAK,GAAhB,EAAqB;AACnBG,QAAAA,MAAM,GAAG,GAAT;AACD,OAFD,MAEO;AACLA,QAAAA,MAAM,GAAG,GAAT;AACD;;AACD,aAAOP,SAAS,CAACK,MAAV,CAAiBJ,SAAS,GAAG,CAA7B,EAAgCK,MAAhC,CAAuC,CAAvC,MAA8CC,MAArD,EAA6D;AAC3DN,QAAAA,SAAS;;AACT,YAAIA,SAAS,GAAG,CAAZ,GAAgBD,SAAS,CAACQ,MAA9B,EAAsC;AACpC;AACD;AACF;;AACDP,MAAAA,SAAS;AACV;;AACD,WAAOA,SAAP;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;AACEQ,EAAAA,kBAAkB,CAACT,SAAD,EAAYC,SAAZ,EAAuBC,IAAvB,EAA6B;AAC7C,QAAIA,IAAI,CAACC,WAAL,KAAqB,MAAzB,EAAiC,OAAOF,SAAP;AACjC,UAAMG,OAAO,GAAGJ,SAAS,CAACK,MAAV,CAAiBJ,SAAjB,EAA4BK,MAA5B,CAAmC,CAAnC,CAAhB;;AACA,QAAIF,OAAO,KAAK,GAAZ,IAAmBA,OAAO,KAAK,GAAnC,EAAwC;AACtC,UAAIG,MAAM,GAAG,EAAb;;AACA,UAAIH,OAAO,KAAK,GAAhB,EAAqB;AACnBG,QAAAA,MAAM,GAAG,GAAT;AACD,OAFD,MAEO;AACLA,QAAAA,MAAM,GAAG,GAAT;AACD;;AACD,aAAOP,SAAS,CAACK,MAAV,CAAiBJ,SAAS,GAAG,CAA7B,EAAgCK,MAAhC,CAAuC,CAAvC,MAA8CC,MAArD,EAA6D;AAC3DN,QAAAA,SAAS;;AACT,YAAIA,SAAS,GAAG,CAAhB,EAAmB;AACjB;AACD;AACF;;AACDA,MAAAA,SAAS;AACV;;AACD,WAAOA,SAAP;AACD;;AA1D6B;AA6DhC,OAAO,IAAIS,UAAU,GAAG,IAAIZ,UAAJ,EAAjB","sourcesContent":["/**\n * TODO: These methods can probably be combined somehow\n * Parse HTML tags & HTML Characters\n */\n\nexport default class HTMLParser {\n  /**\n   * Type HTML tags & HTML Characters\n   * @param {string} curString Current string\n   * @param {number} curStrPos Position in current string\n   * @param {Typed} self instance of Typed\n   * @returns {number} a new string position\n   * @private\n   */\n\n  typeHtmlChars(curString, curStrPos, self) {\n    if (self.contentType !== 'html') return curStrPos;\n    const curChar = curString.substr(curStrPos).charAt(0);\n    if (curChar === '<' || curChar === '&') {\n      let endTag = '';\n      if (curChar === '<') {\n        endTag = '>';\n      } else {\n        endTag = ';';\n      }\n      while (curString.substr(curStrPos + 1).charAt(0) !== endTag) {\n        curStrPos++;\n        if (curStrPos + 1 > curString.length) {\n          break;\n        }\n      }\n      curStrPos++;\n    }\n    return curStrPos;\n  }\n\n  /**\n   * Backspace HTML tags and HTML Characters\n   * @param {string} curString Current string\n   * @param {number} curStrPos Position in current string\n   * @param {Typed} self instance of Typed\n   * @returns {number} a new string position\n   * @private\n   */\n  backSpaceHtmlChars(curString, curStrPos, self) {\n    if (self.contentType !== 'html') return curStrPos;\n    const curChar = curString.substr(curStrPos).charAt(0);\n    if (curChar === '>' || curChar === ';') {\n      let endTag = '';\n      if (curChar === '>') {\n        endTag = '<';\n      } else {\n        endTag = '&';\n      }\n      while (curString.substr(curStrPos - 1).charAt(0) !== endTag) {\n        curStrPos--;\n        if (curStrPos < 0) {\n          break;\n        }\n      }\n      curStrPos--;\n    }\n    return curStrPos;\n  }\n}\n\nexport let htmlParser = new HTMLParser();\n"]},"metadata":{},"sourceType":"module"}