{"ast":null,"code":"import Delta from 'quill-delta';\nimport Parchment from 'parchment';\nimport Block from '../blots/block';\nimport Inline from '../blots/inline';\nimport TextBlot from '../blots/text';\n\nclass Code extends Inline {}\n\nCode.blotName = 'code';\nCode.tagName = 'CODE';\n\nclass CodeBlock extends Block {\n  static create(value) {\n    let domNode = super.create(value);\n    domNode.setAttribute('spellcheck', false);\n    return domNode;\n  }\n\n  static formats() {\n    return true;\n  }\n\n  delta() {\n    let text = this.domNode.textContent;\n\n    if (text.endsWith('\\n')) {\n      // Should always be true\n      text = text.slice(0, -1);\n    }\n\n    return text.split('\\n').reduce((delta, frag) => {\n      return delta.insert(frag).insert('\\n', this.formats());\n    }, new Delta());\n  }\n\n  format(name, value) {\n    if (name === this.statics.blotName && value) return;\n    let [text] = this.descendant(TextBlot, this.length() - 1);\n\n    if (text != null) {\n      text.deleteAt(text.length() - 1, 1);\n    }\n\n    super.format(name, value);\n  }\n\n  formatAt(index, length, name, value) {\n    if (length === 0) return;\n\n    if (Parchment.query(name, Parchment.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {\n      return;\n    }\n\n    let nextNewline = this.newlineIndex(index);\n    if (nextNewline < 0 || nextNewline >= index + length) return;\n    let prevNewline = this.newlineIndex(index, true) + 1;\n    let isolateLength = nextNewline - prevNewline + 1;\n    let blot = this.isolate(prevNewline, isolateLength);\n    let next = blot.next;\n    blot.format(name, value);\n\n    if (next instanceof CodeBlock) {\n      next.formatAt(0, index - prevNewline + length - isolateLength, name, value);\n    }\n  }\n\n  insertAt(index, value, def) {\n    if (def != null) return;\n    let [text, offset] = this.descendant(TextBlot, index);\n    text.insertAt(offset, value);\n  }\n\n  length() {\n    let length = this.domNode.textContent.length;\n\n    if (!this.domNode.textContent.endsWith('\\n')) {\n      return length + 1;\n    }\n\n    return length;\n  }\n\n  newlineIndex(searchIndex, reverse = false) {\n    if (!reverse) {\n      let offset = this.domNode.textContent.slice(searchIndex).indexOf('\\n');\n      return offset > -1 ? searchIndex + offset : -1;\n    } else {\n      return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\\n');\n    }\n  }\n\n  optimize(context) {\n    if (!this.domNode.textContent.endsWith('\\n')) {\n      this.appendChild(Parchment.create('text', '\\n'));\n    }\n\n    super.optimize(context);\n    let next = this.next;\n\n    if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {\n      next.optimize(context);\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  replace(target) {\n    super.replace(target);\n    [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {\n      let blot = Parchment.find(node);\n\n      if (blot == null) {\n        node.parentNode.removeChild(node);\n      } else if (blot instanceof Parchment.Embed) {\n        blot.remove();\n      } else {\n        blot.unwrap();\n      }\n    });\n  }\n\n}\n\nCodeBlock.blotName = 'code-block';\nCodeBlock.tagName = 'PRE';\nCodeBlock.TAB = '  ';\nexport { Code, CodeBlock as default };","map":{"version":3,"sources":["/Users/albab/bookapro/amazon/src/assets/vendor/quill/formats/code.js"],"names":["Delta","Parchment","Block","Inline","TextBlot","Code","blotName","tagName","CodeBlock","create","value","domNode","setAttribute","formats","delta","text","textContent","endsWith","slice","split","reduce","frag","insert","format","name","statics","descendant","length","deleteAt","formatAt","index","query","Scope","BLOCK","nextNewline","newlineIndex","prevNewline","isolateLength","blot","isolate","next","insertAt","def","offset","searchIndex","reverse","indexOf","lastIndexOf","optimize","context","appendChild","prev","moveChildren","remove","replace","target","call","querySelectorAll","forEach","node","find","parentNode","removeChild","Embed","unwrap","TAB","default"],"mappings":"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","sourcesContent":["import Delta from 'quill-delta';\nimport Parchment from 'parchment';\nimport Block from '../blots/block';\nimport Inline from '../blots/inline';\nimport TextBlot from '../blots/text';\n\n\nclass Code extends Inline {}\nCode.blotName = 'code';\nCode.tagName = 'CODE';\n\n\nclass CodeBlock extends Block {\n  static create(value) {\n    let domNode = super.create(value);\n    domNode.setAttribute('spellcheck', false);\n    return domNode;\n  }\n\n  static formats() {\n    return true;\n  }\n\n  delta() {\n    let text = this.domNode.textContent;\n    if (text.endsWith('\\n')) {      // Should always be true\n      text = text.slice(0, -1);\n    }\n    return text.split('\\n').reduce((delta, frag) => {\n      return delta.insert(frag).insert('\\n', this.formats());\n    }, new Delta());\n  }\n\n  format(name, value) {\n    if (name === this.statics.blotName && value) return;\n    let [text, ] = this.descendant(TextBlot, this.length() - 1);\n    if (text != null) {\n      text.deleteAt(text.length() - 1, 1);\n    }\n    super.format(name, value);\n  }\n\n  formatAt(index, length, name, value) {\n    if (length === 0) return;\n    if (Parchment.query(name, Parchment.Scope.BLOCK) == null ||\n        (name === this.statics.blotName && value === this.statics.formats(this.domNode))) {\n      return;\n    }\n    let nextNewline = this.newlineIndex(index);\n    if (nextNewline < 0 || nextNewline >= index + length) return;\n    let prevNewline = this.newlineIndex(index, true) + 1;\n    let isolateLength = nextNewline - prevNewline + 1;\n    let blot = this.isolate(prevNewline, isolateLength);\n    let next = blot.next;\n    blot.format(name, value);\n    if (next instanceof CodeBlock) {\n      next.formatAt(0, index - prevNewline + length - isolateLength, name, value);\n    }\n  }\n\n  insertAt(index, value, def) {\n    if (def != null) return;\n    let [text, offset] = this.descendant(TextBlot, index);\n    text.insertAt(offset, value);\n  }\n\n  length() {\n    let length = this.domNode.textContent.length;\n    if (!this.domNode.textContent.endsWith('\\n')) {\n      return length + 1;\n    }\n    return length;\n  }\n\n  newlineIndex(searchIndex, reverse = false) {\n    if (!reverse) {\n      let offset = this.domNode.textContent.slice(searchIndex).indexOf('\\n');\n      return offset > -1 ? searchIndex + offset : -1;\n    } else {\n      return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\\n');\n    }\n  }\n\n  optimize(context) {\n    if (!this.domNode.textContent.endsWith('\\n')) {\n      this.appendChild(Parchment.create('text', '\\n'));\n    }\n    super.optimize(context);\n    let next = this.next;\n    if (next != null && next.prev === this &&\n        next.statics.blotName === this.statics.blotName &&\n        this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {\n      next.optimize(context);\n      next.moveChildren(this);\n      next.remove();\n    }\n  }\n\n  replace(target) {\n    super.replace(target);\n    [].slice.call(this.domNode.querySelectorAll('*')).forEach(function(node) {\n      let blot = Parchment.find(node);\n      if (blot == null) {\n        node.parentNode.removeChild(node);\n      } else if (blot instanceof Parchment.Embed) {\n        blot.remove();\n      } else {\n        blot.unwrap();\n      }\n    });\n  }\n}\nCodeBlock.blotName = 'code-block';\nCodeBlock.tagName = 'PRE';\nCodeBlock.TAB = '  ';\n\n\nexport { Code, CodeBlock as default };\n"]},"metadata":{},"sourceType":"module"}