{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst AbstractQuery = require('../abstract/query');\n\nconst QueryTypes = require('../../query-types');\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('sqlite');\n\nconst {\n  logger\n} = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n\n\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = {};\n\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    }\n\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err);\n    }\n\n    let result = this.instance; // add the inserted row id to the instance\n\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (metaData.constructor.name === 'Statement' && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({\n              [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i\n            });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n\n      return result;\n    }\n\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      } // This is a map of prefix strings to models, e.g. user.projects -> Project model\n\n\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n      let defaultValue;\n\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = {\n            '0': false,\n            '1': true\n          }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n\n      return result;\n    }\n\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n\n        const query = this; // cannot use arrow function here because the function is bound to the statement\n\n        function afterExecute(executionError, results) {\n          try {\n            complete(); // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        } // If we already have the metadata for the table, there's no need to ask for it again\n\n\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n\n        await Promise.all(tableNames.map(tableName => new Promise(resolve => {\n          tableName = tableName.replace(/`/g, '');\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n\n            resolve();\n          });\n        })));\n      }\n\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'),\n        //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, {\n        timezone: this.sequelize.options.timezone\n      });\n    }\n\n    return value;\n  }\n\n  formatError(err) {\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT':\n        {\n          if (err.message.includes('FOREIGN KEY constraint failed')) {\n            return new sequelizeErrors.ForeignKeyConstraintError({\n              parent: err\n            });\n          }\n\n          let fields = []; // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n\n          let match = err.message.match(/columns (.*?) are/);\n\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ');\n          } else {\n            // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n            match = err.message.match(/UNIQUE constraint failed: (.*)/);\n\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n            }\n          }\n\n          const errors = [];\n          let message = 'Validation error';\n\n          for (const field of fields) {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), 'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field, this.instance && this.instance[field], this.instance, 'not_unique'));\n          }\n\n          if (this.model) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields\n          });\n        }\n\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err);\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n\n    return 'all';\n  }\n\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":{"version":3,"sources":["/Users/albab/bookapro/amazon/node_modules/sequelize/lib/dialects/sqlite/query.js"],"names":["_","require","Utils","AbstractQuery","QueryTypes","sequelizeErrors","parserStore","logger","debug","debugContext","Query","getInsertIdField","formatBindParameters","sql","values","dialect","bindParam","Array","isArray","forEach","v","i","skipValueReplace","k","Object","keys","_collectModels","include","prefix","ret","_include","key","as","model","merge","_handleQueryResponse","metaData","columnTypes","err","results","formatError","result","instance","isInsertQuery","isUpsertQuery","handleInsertQuery","constructor","name","autoIncrementAttribute","primaryKeyAttribute","rawAttributes","startId","changes","push","field","isShowTablesQuery","map","row","isShowConstraintsQuery","parseConstraintsFromSql","isSelectQuery","options","raw","handleSelectQuery","prefixes","mapValues","value","includes","lastind","lastIndexOf","substr","tableName","getTableName","toString","replace","tableTypes","forOwn","attribute","prototype","hasOwnProperty","call","applyParsers","isShowOrDescribeQuery","handleShowIndexesQuery","defaultValue","_result","dflt_value","undefined","type","allowNull","notnull","primaryKey","pk","BULKUPDATE","BULKDELETE","VERSION","version","RAW","isUpdateQuery","run","parameters","conn","connection","method","getDatabaseMethod","complete","_logQuery","Promise","resolve","reject","serialize","executeSql","startsWith","query","afterExecute","executionError","error","tableNames","exec","filter","length","all","constraints","split","referenceTableName","referenceTableKeys","updateAction","deleteAction","splice","constraintSql","match","referencesRegex","referenceConditions","removeTicks","columnNames","column","constraintCondition","constraint","constraintName","constraintType","indexOf","trim","toUpperCase","parse","get","timezone","sequelize","code","message","ForeignKeyConstraintError","parent","fields","columnWithTable","errors","ValidationErrorItem","getUniqueConstraintErrorMessage","uniqueKeys","isEqual","msg","UniqueConstraintError","TimeoutError","DatabaseError","data","reverse","item","primary","unique","columns","seqno","order","isBulkUpdateQuery","toLowerCase","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n        const query = this;\n        // cannot use arrow function here because the function is bound to the statement\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n        conn[method](sql, parameters, afterExecute);\n\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        // If we already have the metadata for the table, there's no need to ask for it again\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName =>\n          new Promise(resolve => {\n            tableName = tableName.replace(/`/g, '');\n            columnTypes[tableName] = {};\n\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n              if (!err) {\n                for (const result of results) {\n                  columnTypes[tableName][result.name] = result.type;\n                }\n              }\n              resolve();\n            });\n          })));\n      }\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err);\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"]},"metadata":{},"sourceType":"script"}