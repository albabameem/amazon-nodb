{"ast":null,"code":"import { initializer } from './initializer.js';\nimport { htmlParser } from './html-parser.js';\n/**\n * Welcome to Typed.js!\n * @param {string} elementId HTML element ID _OR_ HTML element\n * @param {object} options options object\n * @returns {object} a new Typed object\n */\n\nexport default class Typed {\n  constructor(elementId, options) {\n    // Initialize it up\n    initializer.load(this, options, elementId); // All systems go!\n\n    this.begin();\n  }\n  /**\n   * Toggle start() and stop() of the Typed instance\n   * @public\n   */\n\n\n  toggle() {\n    this.pause.status ? this.start() : this.stop();\n  }\n  /**\n   * Stop typing / backspacing and enable cursor blinking\n   * @public\n   */\n\n\n  stop() {\n    if (this.typingComplete) return;\n    if (this.pause.status) return;\n    this.toggleBlinking(true);\n    this.pause.status = true;\n    this.options.onStop(this.arrayPos, this);\n  }\n  /**\n   * Start typing / backspacing after being stopped\n   * @public\n   */\n\n\n  start() {\n    if (this.typingComplete) return;\n    if (!this.pause.status) return;\n    this.pause.status = false;\n\n    if (this.pause.typewrite) {\n      this.typewrite(this.pause.curString, this.pause.curStrPos);\n    } else {\n      this.backspace(this.pause.curString, this.pause.curStrPos);\n    }\n\n    this.options.onStart(this.arrayPos, this);\n  }\n  /**\n   * Destroy this instance of Typed\n   * @public\n   */\n\n\n  destroy() {\n    this.reset(false);\n    this.options.onDestroy(this);\n  }\n  /**\n   * Reset Typed and optionally restarts\n   * @param {boolean} restart\n   * @public\n   */\n\n\n  reset(restart = true) {\n    clearInterval(this.timeout);\n    this.replaceText('');\n\n    if (this.cursor && this.cursor.parentNode) {\n      this.cursor.parentNode.removeChild(this.cursor);\n      this.cursor = null;\n    }\n\n    this.strPos = 0;\n    this.arrayPos = 0;\n    this.curLoop = 0;\n\n    if (restart) {\n      this.insertCursor();\n      this.options.onReset(this);\n      this.begin();\n    }\n  }\n  /**\n   * Begins the typing animation\n   * @private\n   */\n\n\n  begin() {\n    this.options.onBegin(this);\n    this.typingComplete = false;\n    this.shuffleStringsIfNeeded(this);\n    this.insertCursor();\n    if (this.bindInputFocusEvents) this.bindFocusEvents();\n    this.timeout = setTimeout(() => {\n      // Check if there is some text in the element, if yes start by backspacing the default message\n      if (!this.currentElContent || this.currentElContent.length === 0) {\n        this.typewrite(this.strings[this.sequence[this.arrayPos]], this.strPos);\n      } else {\n        // Start typing\n        this.backspace(this.currentElContent, this.currentElContent.length);\n      }\n    }, this.startDelay);\n  }\n  /**\n   * Called for each character typed\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @private\n   */\n\n\n  typewrite(curString, curStrPos) {\n    if (this.fadeOut && this.el.classList.contains(this.fadeOutClass)) {\n      this.el.classList.remove(this.fadeOutClass);\n      if (this.cursor) this.cursor.classList.remove(this.fadeOutClass);\n    }\n\n    const humanize = this.humanizer(this.typeSpeed);\n    let numChars = 1;\n\n    if (this.pause.status === true) {\n      this.setPauseStatus(curString, curStrPos, true);\n      return;\n    } // contain typing function in a timeout humanize'd delay\n\n\n    this.timeout = setTimeout(() => {\n      // skip over any HTML chars\n      curStrPos = htmlParser.typeHtmlChars(curString, curStrPos, this);\n      let pauseTime = 0;\n      let substr = curString.substr(curStrPos); // check for an escape character before a pause value\n      // format: \\^\\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^\n      // single ^ are removed from string\n\n      if (substr.charAt(0) === '^') {\n        if (/^\\^\\d+/.test(substr)) {\n          let skip = 1; // skip at least 1\n\n          substr = /\\d+/.exec(substr)[0];\n          skip += substr.length;\n          pauseTime = parseInt(substr);\n          this.temporaryPause = true;\n          this.options.onTypingPaused(this.arrayPos, this); // strip out the escape character and pause value so they're not printed\n\n          curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);\n          this.toggleBlinking(true);\n        }\n      } // check for skip characters formatted as\n      // \"this is a `string to print NOW` ...\"\n\n\n      if (substr.charAt(0) === '`') {\n        while (curString.substr(curStrPos + numChars).charAt(0) !== '`') {\n          numChars++;\n          if (curStrPos + numChars > curString.length) break;\n        } // strip out the escape characters and append all the string in between\n\n\n        const stringBeforeSkip = curString.substring(0, curStrPos);\n        const stringSkipped = curString.substring(stringBeforeSkip.length + 1, curStrPos + numChars);\n        const stringAfterSkip = curString.substring(curStrPos + numChars + 1);\n        curString = stringBeforeSkip + stringSkipped + stringAfterSkip;\n        numChars--;\n      } // timeout for any pause after a character\n\n\n      this.timeout = setTimeout(() => {\n        // Accounts for blinking while paused\n        this.toggleBlinking(false); // We're done with this sentence!\n\n        if (curStrPos >= curString.length) {\n          this.doneTyping(curString, curStrPos);\n        } else {\n          this.keepTyping(curString, curStrPos, numChars);\n        } // end of character pause\n\n\n        if (this.temporaryPause) {\n          this.temporaryPause = false;\n          this.options.onTypingResumed(this.arrayPos, this);\n        }\n      }, pauseTime); // humanized value for typing\n    }, humanize);\n  }\n  /**\n   * Continue to the next string & begin typing\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @private\n   */\n\n\n  keepTyping(curString, curStrPos, numChars) {\n    // call before functions if applicable\n    if (curStrPos === 0) {\n      this.toggleBlinking(false);\n      this.options.preStringTyped(this.arrayPos, this);\n    } // start typing each new char into existing string\n    // curString: arg, this.el.html: original text inside element\n\n\n    curStrPos += numChars;\n    const nextString = curString.substr(0, curStrPos);\n    this.replaceText(nextString); // loop the function\n\n    this.typewrite(curString, curStrPos);\n  }\n  /**\n   * We're done typing the current string\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @private\n   */\n\n\n  doneTyping(curString, curStrPos) {\n    // fires callback function\n    this.options.onStringTyped(this.arrayPos, this);\n    this.toggleBlinking(true); // is this the final string\n\n    if (this.arrayPos === this.strings.length - 1) {\n      // callback that occurs on the last typed string\n      this.complete(); // quit if we wont loop back\n\n      if (this.loop === false || this.curLoop === this.loopCount) {\n        return;\n      }\n    }\n\n    this.timeout = setTimeout(() => {\n      this.backspace(curString, curStrPos);\n    }, this.backDelay);\n  }\n  /**\n   * Backspaces 1 character at a time\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @private\n   */\n\n\n  backspace(curString, curStrPos) {\n    if (this.pause.status === true) {\n      this.setPauseStatus(curString, curStrPos, true);\n      return;\n    }\n\n    if (this.fadeOut) return this.initFadeOut();\n    this.toggleBlinking(false);\n    const humanize = this.humanizer(this.backSpeed);\n    this.timeout = setTimeout(() => {\n      curStrPos = htmlParser.backSpaceHtmlChars(curString, curStrPos, this); // replace text with base text + typed characters\n\n      const curStringAtPosition = curString.substr(0, curStrPos);\n      this.replaceText(curStringAtPosition); // if smartBack is enabled\n\n      if (this.smartBackspace) {\n        // the remaining part of the current string is equal of the same part of the new string\n        let nextString = this.strings[this.arrayPos + 1];\n\n        if (nextString && curStringAtPosition === nextString.substr(0, curStrPos)) {\n          this.stopNum = curStrPos;\n        } else {\n          this.stopNum = 0;\n        }\n      } // if the number (id of character in current string) is\n      // less than the stop number, keep going\n\n\n      if (curStrPos > this.stopNum) {\n        // subtract characters one by one\n        curStrPos--; // loop the function\n\n        this.backspace(curString, curStrPos);\n      } else if (curStrPos <= this.stopNum) {\n        // if the stop number has been reached, increase\n        // array position to next string\n        this.arrayPos++; // When looping, begin at the beginning after backspace complete\n\n        if (this.arrayPos === this.strings.length) {\n          this.arrayPos = 0;\n          this.options.onLastStringBackspaced();\n          this.shuffleStringsIfNeeded();\n          this.begin();\n        } else {\n          this.typewrite(this.strings[this.sequence[this.arrayPos]], curStrPos);\n        }\n      } // humanized value for typing\n\n    }, humanize);\n  }\n  /**\n   * Full animation is complete\n   * @private\n   */\n\n\n  complete() {\n    this.options.onComplete(this);\n\n    if (this.loop) {\n      this.curLoop++;\n    } else {\n      this.typingComplete = true;\n    }\n  }\n  /**\n   * Has the typing been stopped\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @param {boolean} isTyping\n   * @private\n   */\n\n\n  setPauseStatus(curString, curStrPos, isTyping) {\n    this.pause.typewrite = isTyping;\n    this.pause.curString = curString;\n    this.pause.curStrPos = curStrPos;\n  }\n  /**\n   * Toggle the blinking cursor\n   * @param {boolean} isBlinking\n   * @private\n   */\n\n\n  toggleBlinking(isBlinking) {\n    if (!this.cursor) return; // if in paused state, don't toggle blinking a 2nd time\n\n    if (this.pause.status) return;\n    if (this.cursorBlinking === isBlinking) return;\n    this.cursorBlinking = isBlinking;\n\n    if (isBlinking) {\n      this.cursor.classList.add('typed-cursor--blink');\n    } else {\n      this.cursor.classList.remove('typed-cursor--blink');\n    }\n  }\n  /**\n   * Speed in MS to type\n   * @param {number} speed\n   * @private\n   */\n\n\n  humanizer(speed) {\n    return Math.round(Math.random() * speed / 2) + speed;\n  }\n  /**\n   * Shuffle the sequence of the strings array\n   * @private\n   */\n\n\n  shuffleStringsIfNeeded() {\n    if (!this.shuffle) return;\n    this.sequence = this.sequence.sort(() => Math.random() - 0.5);\n  }\n  /**\n   * Adds a CSS class to fade out current string\n   * @private\n   */\n\n\n  initFadeOut() {\n    this.el.className += ` ${this.fadeOutClass}`;\n    if (this.cursor) this.cursor.className += ` ${this.fadeOutClass}`;\n    return setTimeout(() => {\n      this.arrayPos++;\n      this.replaceText(''); // Resets current string if end of loop reached\n\n      if (this.strings.length > this.arrayPos) {\n        this.typewrite(this.strings[this.sequence[this.arrayPos]], 0);\n      } else {\n        this.typewrite(this.strings[0], 0);\n        this.arrayPos = 0;\n      }\n    }, this.fadeOutDelay);\n  }\n  /**\n   * Replaces current text in the HTML element\n   * depending on element type\n   * @param {string} str\n   * @private\n   */\n\n\n  replaceText(str) {\n    if (this.attr) {\n      this.el.setAttribute(this.attr, str);\n    } else {\n      if (this.isInput) {\n        this.el.value = str;\n      } else if (this.contentType === 'html') {\n        this.el.innerHTML = str;\n      } else {\n        this.el.textContent = str;\n      }\n    }\n  }\n  /**\n   * If using input elements, bind focus in order to\n   * start and stop the animation\n   * @private\n   */\n\n\n  bindFocusEvents() {\n    if (!this.isInput) return;\n    this.el.addEventListener('focus', e => {\n      this.stop();\n    });\n    this.el.addEventListener('blur', e => {\n      if (this.el.value && this.el.value.length !== 0) {\n        return;\n      }\n\n      this.start();\n    });\n  }\n  /**\n   * On init, insert the cursor element\n   * @private\n   */\n\n\n  insertCursor() {\n    if (!this.showCursor) return;\n    if (this.cursor) return;\n    this.cursor = document.createElement('span');\n    this.cursor.className = 'typed-cursor';\n    this.cursor.innerHTML = this.cursorChar;\n    this.el.parentNode && this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling);\n  }\n\n}","map":{"version":3,"sources":["/Users/albab/bookapro/amazon/src/assets/vendor/typed.js/src/typed.js"],"names":["initializer","htmlParser","Typed","constructor","elementId","options","load","begin","toggle","pause","status","start","stop","typingComplete","toggleBlinking","onStop","arrayPos","typewrite","curString","curStrPos","backspace","onStart","destroy","reset","onDestroy","restart","clearInterval","timeout","replaceText","cursor","parentNode","removeChild","strPos","curLoop","insertCursor","onReset","onBegin","shuffleStringsIfNeeded","bindInputFocusEvents","bindFocusEvents","setTimeout","currentElContent","length","strings","sequence","startDelay","fadeOut","el","classList","contains","fadeOutClass","remove","humanize","humanizer","typeSpeed","numChars","setPauseStatus","typeHtmlChars","pauseTime","substr","charAt","test","skip","exec","parseInt","temporaryPause","onTypingPaused","substring","stringBeforeSkip","stringSkipped","stringAfterSkip","doneTyping","keepTyping","onTypingResumed","preStringTyped","nextString","onStringTyped","complete","loop","loopCount","backDelay","initFadeOut","backSpeed","backSpaceHtmlChars","curStringAtPosition","smartBackspace","stopNum","onLastStringBackspaced","onComplete","isTyping","isBlinking","cursorBlinking","add","speed","Math","round","random","shuffle","sort","className","fadeOutDelay","str","attr","setAttribute","isInput","value","contentType","innerHTML","textContent","addEventListener","e","showCursor","document","createElement","cursorChar","insertBefore","nextSibling"],"mappings":"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","sourcesContent":["import { initializer } from './initializer.js';\nimport { htmlParser } from './html-parser.js';\n\n/**\n * Welcome to Typed.js!\n * @param {string} elementId HTML element ID _OR_ HTML element\n * @param {object} options options object\n * @returns {object} a new Typed object\n */\nexport default class Typed {\n  constructor(elementId, options) {\n    // Initialize it up\n    initializer.load(this, options, elementId);\n    // All systems go!\n    this.begin();\n  }\n\n  /**\n   * Toggle start() and stop() of the Typed instance\n   * @public\n   */\n  toggle() {\n    this.pause.status ? this.start() : this.stop();\n  }\n\n  /**\n   * Stop typing / backspacing and enable cursor blinking\n   * @public\n   */\n  stop() {\n    if (this.typingComplete) return;\n    if (this.pause.status) return;\n    this.toggleBlinking(true);\n    this.pause.status = true;\n    this.options.onStop(this.arrayPos, this);\n  }\n\n  /**\n   * Start typing / backspacing after being stopped\n   * @public\n   */\n  start() {\n    if (this.typingComplete) return;\n    if (!this.pause.status) return;\n    this.pause.status = false;\n    if (this.pause.typewrite) {\n      this.typewrite(this.pause.curString, this.pause.curStrPos);\n    } else {\n      this.backspace(this.pause.curString, this.pause.curStrPos);\n    }\n    this.options.onStart(this.arrayPos, this);\n  }\n\n  /**\n   * Destroy this instance of Typed\n   * @public\n   */\n  destroy() {\n    this.reset(false);\n    this.options.onDestroy(this);\n  }\n\n  /**\n   * Reset Typed and optionally restarts\n   * @param {boolean} restart\n   * @public\n   */\n  reset(restart = true) {\n    clearInterval(this.timeout);\n    this.replaceText('');\n    if (this.cursor && this.cursor.parentNode) {\n      this.cursor.parentNode.removeChild(this.cursor);\n      this.cursor = null;\n    }\n    this.strPos = 0;\n    this.arrayPos = 0;\n    this.curLoop = 0;\n    if (restart) {\n      this.insertCursor();\n      this.options.onReset(this);\n      this.begin();\n    }\n  }\n\n  /**\n   * Begins the typing animation\n   * @private\n   */\n  begin() {\n    this.options.onBegin(this);\n    this.typingComplete = false;\n    this.shuffleStringsIfNeeded(this);\n    this.insertCursor();\n    if (this.bindInputFocusEvents) this.bindFocusEvents();\n    this.timeout = setTimeout(() => {\n      // Check if there is some text in the element, if yes start by backspacing the default message\n      if (!this.currentElContent || this.currentElContent.length === 0) {\n        this.typewrite(this.strings[this.sequence[this.arrayPos]], this.strPos);\n      } else {\n        // Start typing\n        this.backspace(this.currentElContent, this.currentElContent.length);\n      }\n    }, this.startDelay);\n  }\n\n  /**\n   * Called for each character typed\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @private\n   */\n  typewrite(curString, curStrPos) {\n    if (this.fadeOut && this.el.classList.contains(this.fadeOutClass)) {\n      this.el.classList.remove(this.fadeOutClass);\n      if (this.cursor) this.cursor.classList.remove(this.fadeOutClass);\n    }\n\n    const humanize = this.humanizer(this.typeSpeed);\n    let numChars = 1;\n\n    if (this.pause.status === true) {\n      this.setPauseStatus(curString, curStrPos, true);\n      return;\n    }\n\n    // contain typing function in a timeout humanize'd delay\n    this.timeout = setTimeout(() => {\n      // skip over any HTML chars\n      curStrPos = htmlParser.typeHtmlChars(curString, curStrPos, this);\n\n      let pauseTime = 0;\n      let substr = curString.substr(curStrPos);\n      // check for an escape character before a pause value\n      // format: \\^\\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^\n      // single ^ are removed from string\n      if (substr.charAt(0) === '^') {\n        if (/^\\^\\d+/.test(substr)) {\n          let skip = 1; // skip at least 1\n          substr = /\\d+/.exec(substr)[0];\n          skip += substr.length;\n          pauseTime = parseInt(substr);\n          this.temporaryPause = true;\n          this.options.onTypingPaused(this.arrayPos, this);\n          // strip out the escape character and pause value so they're not printed\n          curString =\n            curString.substring(0, curStrPos) +\n            curString.substring(curStrPos + skip);\n          this.toggleBlinking(true);\n        }\n      }\n\n      // check for skip characters formatted as\n      // \"this is a `string to print NOW` ...\"\n      if (substr.charAt(0) === '`') {\n        while (curString.substr(curStrPos + numChars).charAt(0) !== '`') {\n          numChars++;\n          if (curStrPos + numChars > curString.length) break;\n        }\n        // strip out the escape characters and append all the string in between\n        const stringBeforeSkip = curString.substring(0, curStrPos);\n        const stringSkipped = curString.substring(\n          stringBeforeSkip.length + 1,\n          curStrPos + numChars\n        );\n        const stringAfterSkip = curString.substring(curStrPos + numChars + 1);\n        curString = stringBeforeSkip + stringSkipped + stringAfterSkip;\n        numChars--;\n      }\n\n      // timeout for any pause after a character\n      this.timeout = setTimeout(() => {\n        // Accounts for blinking while paused\n        this.toggleBlinking(false);\n\n        // We're done with this sentence!\n        if (curStrPos >= curString.length) {\n          this.doneTyping(curString, curStrPos);\n        } else {\n          this.keepTyping(curString, curStrPos, numChars);\n        }\n        // end of character pause\n        if (this.temporaryPause) {\n          this.temporaryPause = false;\n          this.options.onTypingResumed(this.arrayPos, this);\n        }\n      }, pauseTime);\n\n      // humanized value for typing\n    }, humanize);\n  }\n\n  /**\n   * Continue to the next string & begin typing\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @private\n   */\n  keepTyping(curString, curStrPos, numChars) {\n    // call before functions if applicable\n    if (curStrPos === 0) {\n      this.toggleBlinking(false);\n      this.options.preStringTyped(this.arrayPos, this);\n    }\n    // start typing each new char into existing string\n    // curString: arg, this.el.html: original text inside element\n    curStrPos += numChars;\n    const nextString = curString.substr(0, curStrPos);\n    this.replaceText(nextString);\n    // loop the function\n    this.typewrite(curString, curStrPos);\n  }\n\n  /**\n   * We're done typing the current string\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @private\n   */\n  doneTyping(curString, curStrPos) {\n    // fires callback function\n    this.options.onStringTyped(this.arrayPos, this);\n    this.toggleBlinking(true);\n    // is this the final string\n    if (this.arrayPos === this.strings.length - 1) {\n      // callback that occurs on the last typed string\n      this.complete();\n      // quit if we wont loop back\n      if (this.loop === false || this.curLoop === this.loopCount) {\n        return;\n      }\n    }\n    this.timeout = setTimeout(() => {\n      this.backspace(curString, curStrPos);\n    }, this.backDelay);\n  }\n\n  /**\n   * Backspaces 1 character at a time\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @private\n   */\n  backspace(curString, curStrPos) {\n    if (this.pause.status === true) {\n      this.setPauseStatus(curString, curStrPos, true);\n      return;\n    }\n    if (this.fadeOut) return this.initFadeOut();\n\n    this.toggleBlinking(false);\n    const humanize = this.humanizer(this.backSpeed);\n\n    this.timeout = setTimeout(() => {\n      curStrPos = htmlParser.backSpaceHtmlChars(curString, curStrPos, this);\n      // replace text with base text + typed characters\n      const curStringAtPosition = curString.substr(0, curStrPos);\n      this.replaceText(curStringAtPosition);\n\n      // if smartBack is enabled\n      if (this.smartBackspace) {\n        // the remaining part of the current string is equal of the same part of the new string\n        let nextString = this.strings[this.arrayPos + 1];\n        if (\n          nextString &&\n          curStringAtPosition === nextString.substr(0, curStrPos)\n        ) {\n          this.stopNum = curStrPos;\n        } else {\n          this.stopNum = 0;\n        }\n      }\n\n      // if the number (id of character in current string) is\n      // less than the stop number, keep going\n      if (curStrPos > this.stopNum) {\n        // subtract characters one by one\n        curStrPos--;\n        // loop the function\n        this.backspace(curString, curStrPos);\n      } else if (curStrPos <= this.stopNum) {\n        // if the stop number has been reached, increase\n        // array position to next string\n        this.arrayPos++;\n        // When looping, begin at the beginning after backspace complete\n        if (this.arrayPos === this.strings.length) {\n          this.arrayPos = 0;\n          this.options.onLastStringBackspaced();\n          this.shuffleStringsIfNeeded();\n          this.begin();\n        } else {\n          this.typewrite(this.strings[this.sequence[this.arrayPos]], curStrPos);\n        }\n      }\n      // humanized value for typing\n    }, humanize);\n  }\n\n  /**\n   * Full animation is complete\n   * @private\n   */\n  complete() {\n    this.options.onComplete(this);\n    if (this.loop) {\n      this.curLoop++;\n    } else {\n      this.typingComplete = true;\n    }\n  }\n\n  /**\n   * Has the typing been stopped\n   * @param {string} curString the current string in the strings array\n   * @param {number} curStrPos the current position in the curString\n   * @param {boolean} isTyping\n   * @private\n   */\n  setPauseStatus(curString, curStrPos, isTyping) {\n    this.pause.typewrite = isTyping;\n    this.pause.curString = curString;\n    this.pause.curStrPos = curStrPos;\n  }\n\n  /**\n   * Toggle the blinking cursor\n   * @param {boolean} isBlinking\n   * @private\n   */\n  toggleBlinking(isBlinking) {\n    if (!this.cursor) return;\n    // if in paused state, don't toggle blinking a 2nd time\n    if (this.pause.status) return;\n    if (this.cursorBlinking === isBlinking) return;\n    this.cursorBlinking = isBlinking;\n    if (isBlinking) {\n      this.cursor.classList.add('typed-cursor--blink');\n    } else {\n      this.cursor.classList.remove('typed-cursor--blink');\n    }\n  }\n\n  /**\n   * Speed in MS to type\n   * @param {number} speed\n   * @private\n   */\n  humanizer(speed) {\n    return Math.round((Math.random() * speed) / 2) + speed;\n  }\n\n  /**\n   * Shuffle the sequence of the strings array\n   * @private\n   */\n  shuffleStringsIfNeeded() {\n    if (!this.shuffle) return;\n    this.sequence = this.sequence.sort(() => Math.random() - 0.5);\n  }\n\n  /**\n   * Adds a CSS class to fade out current string\n   * @private\n   */\n  initFadeOut() {\n    this.el.className += ` ${this.fadeOutClass}`;\n    if (this.cursor) this.cursor.className += ` ${this.fadeOutClass}`;\n    return setTimeout(() => {\n      this.arrayPos++;\n      this.replaceText('');\n\n      // Resets current string if end of loop reached\n      if (this.strings.length > this.arrayPos) {\n        this.typewrite(this.strings[this.sequence[this.arrayPos]], 0);\n      } else {\n        this.typewrite(this.strings[0], 0);\n        this.arrayPos = 0;\n      }\n    }, this.fadeOutDelay);\n  }\n\n  /**\n   * Replaces current text in the HTML element\n   * depending on element type\n   * @param {string} str\n   * @private\n   */\n  replaceText(str) {\n    if (this.attr) {\n      this.el.setAttribute(this.attr, str);\n    } else {\n      if (this.isInput) {\n        this.el.value = str;\n      } else if (this.contentType === 'html') {\n        this.el.innerHTML = str;\n      } else {\n        this.el.textContent = str;\n      }\n    }\n  }\n\n  /**\n   * If using input elements, bind focus in order to\n   * start and stop the animation\n   * @private\n   */\n  bindFocusEvents() {\n    if (!this.isInput) return;\n    this.el.addEventListener('focus', (e) => {\n      this.stop();\n    });\n    this.el.addEventListener('blur', (e) => {\n      if (this.el.value && this.el.value.length !== 0) {\n        return;\n      }\n      this.start();\n    });\n  }\n\n  /**\n   * On init, insert the cursor element\n   * @private\n   */\n  insertCursor() {\n    if (!this.showCursor) return;\n    if (this.cursor) return;\n    this.cursor = document.createElement('span');\n    this.cursor.className = 'typed-cursor';\n    this.cursor.innerHTML = this.cursorChar;\n    this.el.parentNode &&\n      this.el.parentNode.insertBefore(this.cursor, this.el.nextSibling);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}