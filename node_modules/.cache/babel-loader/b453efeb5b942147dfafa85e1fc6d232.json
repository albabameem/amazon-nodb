{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst wkx = require('wkx');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n  /**\n   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {object} dataType The base integer data type.\n   * @private\n   */\n\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = undefined;\n      dataType.options.length = undefined;\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n  /**\n   * types:\n   * {\n   *   oids: [oid],\n   *   array_oids: [oid]\n   * }\n   *\n   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go\n   */\n\n\n  BaseTypes.UUID.types.postgres = ['uuid'];\n  BaseTypes.CIDR.types.postgres = ['cidr'];\n  BaseTypes.INET.types.postgres = ['inet'];\n  BaseTypes.MACADDR.types.postgres = ['macaddr'];\n  BaseTypes.TSVECTOR.types.postgres = ['tsvector'];\n  BaseTypes.JSON.types.postgres = ['json'];\n  BaseTypes.JSONB.types.postgres = ['jsonb'];\n  BaseTypes.TIME.types.postgres = ['time'];\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n\n      return super._stringify(value, options);\n    }\n\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n\n        return super._sanitize(value);\n      }\n\n      return value;\n    }\n\n    static parse(value) {\n      if (value === 'infinity') {\n        return Infinity;\n      }\n\n      if (value === '-infinity') {\n        return -Infinity;\n      }\n\n      return value;\n    }\n\n  }\n\n  BaseTypes.DATEONLY.types.postgres = ['date'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n\n  } // numeric\n\n\n  BaseTypes.DECIMAL.types.postgres = ['numeric'];\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n\n      return super.toSql();\n    }\n\n  }\n\n  BaseTypes.STRING.types.postgres = ['varchar'];\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n        this._length = undefined;\n      }\n\n      return 'TEXT';\n    }\n\n  }\n\n  BaseTypes.TEXT.types.postgres = ['text'];\n\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n\n  }\n\n  BaseTypes.CITEXT.types.postgres = ['citext'];\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n\n      return super.toSql();\n    }\n\n  }\n\n  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'BOOLEAN';\n    }\n\n    _sanitize(value) {\n      if (value !== null && value !== undefined) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          // Bit fields are returned as buffers\n          value = value[0];\n        }\n\n        if (typeof value === 'string') {\n          // Only take action on valid boolean strings.\n          return value === 'true' || value === 't' ? true : value === 'false' || value === 'f' ? false : value;\n        }\n\n        if (typeof value === 'number') {\n          // Only take action on valid boolean integers.\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n\n      return value;\n    }\n\n  }\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n  BaseTypes.BOOLEAN.types.postgres = ['bool'];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH TIME ZONE';\n    }\n\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n\n      return true;\n    }\n\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n\n      return super._stringify(value, options);\n    }\n\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n\n        return new Date(value);\n      }\n\n      return value;\n    }\n\n  }\n\n  BaseTypes.DATE.types.postgres = ['timestamptz'];\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  } // int2\n\n\n  BaseTypes.TINYINT.types.postgres = ['int2'];\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  } // int2\n\n\n  BaseTypes.SMALLINT.types.postgres = ['int2'];\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  }\n\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  }; // int4\n\n\n  BaseTypes.INTEGER.types.postgres = ['int4'];\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  } // int8\n\n\n  BaseTypes.BIGINT.types.postgres = ['int8'];\n\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  } // float4\n\n\n  BaseTypes.REAL.types.postgres = ['float4'];\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n\n  } // float8\n\n\n  BaseTypes.DOUBLE.types.postgres = ['float8'];\n\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals); // POSTGRES does only support lengths as parameter.\n      // Values between 1-24 result in REAL\n      // Values between 25-53 result in DOUBLE PRECISION\n      // If decimals are provided remove these and print a warning\n\n      if (this._decimals) {\n        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._decimals = undefined;\n      }\n\n      if (this._unsigned) {\n        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n        this._unsigned = undefined;\n      }\n\n      if (this._zerofill) {\n        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n        this._zerofill = undefined;\n      }\n    }\n\n  }\n\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n        this._length = undefined;\n      }\n\n      return 'BYTEA';\n    }\n\n    _hexify(hex) {\n      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n      return `E'\\\\\\\\x${hex}'`;\n    }\n\n  }\n\n  BaseTypes.BLOB.types.postgres = ['bytea'];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n\n      if (this.type) {\n        result += `(${this.type}`;\n\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n\n        result += ')';\n      }\n\n      return result;\n    }\n\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({\n        shortCrs: true\n      });\n    }\n\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n\n  }\n\n  BaseTypes.GEOMETRY.types.postgres = ['geometry'];\n\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = 'GEOGRAPHY';\n\n      if (this.type) {\n        result += `(${this.type}`;\n\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n\n        result += ')';\n      }\n\n      return result;\n    }\n\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({\n        shortCrs: true\n      });\n    }\n\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n\n  }\n\n  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];\n  let hstore;\n\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n    }\n\n    _value(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n\n      return hstore.stringify(value);\n    }\n\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n\n    static parse(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n\n      return hstore.parse(value);\n    }\n\n  }\n\n  HSTORE.prototype.escape = false;\n  BaseTypes.HSTORE.types.postgres = ['hstore'];\n\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {\n          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {\n            valueInclusivity[index] = value.inclusive;\n          }\n\n          value = value.value;\n        }\n\n        if (value === null || value === -Infinity || value === Infinity) {\n          // Pass through \"unbounded\" bounds unchanged\n          return value;\n        }\n\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n\n        return options.escape(value);\n      }); // Array.map does not preserve extra array properties\n\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n\n    _stringify(values, options) {\n      const value = this._value(values, options);\n\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n\n      return `'${value}'`;\n    }\n\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n\n      return options.bindParam(value);\n    }\n\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n\n    static parse(value, options = {\n      parser: val => val\n    }) {\n      return range.parse(value, options.parser);\n    }\n\n  }\n\n  const range = require('./range');\n\n  RANGE.prototype.escape = false;\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: 'int4range',\n      decimal: 'numrange',\n      date: 'tstzrange',\n      dateonly: 'daterange',\n      bigint: 'int8range'\n    },\n    castTypes: {\n      integer: 'int4',\n      decimal: 'numeric',\n      date: 'timestamptz',\n      dateonly: 'date',\n      bigint: 'int8'\n    }\n  }; // TODO: Why are base types being manipulated??\n\n  BaseTypes.ARRAY.prototype.escape = false;\n\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map(value => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n\n      return options.escape(value);\n    }, this);\n  };\n\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(',')}]`;\n\n    if (this.type) {\n      const Utils = require('../../utils');\n\n      let castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        castKey = `${Utils.addTicks(Utils.generateEnumName(options.field.Model.getTableName(), options.field.fieldName), '\"')}[]`;\n      }\n\n      str += `::${castKey}`;\n    }\n\n    return str;\n  };\n\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n\n  }\n\n  BaseTypes.ENUM.types.postgres = [null];\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};","map":{"version":3,"sources":["/Users/albab/bookapro/amazon/node_modules/sequelize/lib/dialects/postgres/data-types.js"],"names":["_","require","wkx","module","exports","BaseTypes","warn","ABSTRACT","bind","undefined","removeUnsupportedIntegerOptions","dataType","_length","options","length","_unsigned","_zerofill","key","UUID","types","postgres","CIDR","INET","MACADDR","TSVECTOR","JSON","JSONB","TIME","DATEONLY","_stringify","value","Infinity","_sanitize","raw","lower","toLowerCase","parse","DECIMAL","STRING","toSql","_binary","TEXT","CITEXT","CHAR","BOOLEAN","Buffer","isBuffer","prototype","DATE","validate","Date","TINYINT","constructor","SMALLINT","INTEGER","parseInt","BIGINT","REAL","DOUBLE","FLOAT","decimals","_decimals","BLOB","_hexify","hex","GEOMETRY","result","type","srid","b","from","Geometry","toGeoJSON","shortCrs","escape","stringify","_bindParam","bindParam","GEOGRAPHY","hstore","HSTORE","_value","RANGE","values","Array","isArray","subtype","valueInclusivity","valuesStringified","map","index","isObject","Object","hasOwnProperty","call","inclusive","range","toCastType","subtypes","_subtype","castTypes","parser","val","integer","decimal","date","dateonly","bigint","ARRAY","str","join","Utils","castKey","ENUM","addTicks","generateEnumName","field","Model","getTableName","fieldName"],"mappings":"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","sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst wkx = require('wkx');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(undefined, 'http://www.postgresql.org/docs/9.4/static/datatype.html');\n\n  /**\n   * Removes unsupported Postgres options, i.e., LENGTH, UNSIGNED and ZEROFILL, for the integer data types.\n   *\n   * @param {object} dataType The base integer data type.\n   * @private\n   */\n  function removeUnsupportedIntegerOptions(dataType) {\n    if (dataType._length || dataType.options.length || dataType._unsigned || dataType._zerofill) {\n      warn(`PostgresSQL does not support '${dataType.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${dataType.key}' will be used instead.`);\n      dataType._length = undefined;\n      dataType.options.length = undefined;\n      dataType._unsigned = undefined;\n      dataType._zerofill = undefined;\n    }\n  }\n\n  /**\n   * types:\n   * {\n   *   oids: [oid],\n   *   array_oids: [oid]\n   * }\n   *\n   * @see oid here https://github.com/lib/pq/blob/master/oid/types.go\n   */\n\n  BaseTypes.UUID.types.postgres = ['uuid'];\n  BaseTypes.CIDR.types.postgres = ['cidr'];\n  BaseTypes.INET.types.postgres = ['inet'];\n  BaseTypes.MACADDR.types.postgres = ['macaddr'];\n  BaseTypes.TSVECTOR.types.postgres = ['tsvector'];\n  BaseTypes.JSON.types.postgres = ['json'];\n  BaseTypes.JSONB.types.postgres = ['jsonb'];\n  BaseTypes.TIME.types.postgres = ['time'];\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return super._sanitize(value);\n      }\n      return value;\n    }\n    static parse(value) {\n      if (value === 'infinity') {\n        return Infinity;\n      }\n      if (value === '-infinity') {\n        return -Infinity;\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATEONLY.types.postgres = ['date'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  // numeric\n  BaseTypes.DECIMAL.types.postgres = ['numeric'];\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.STRING.types.postgres = ['varchar'];\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead.');\n        this._length = undefined;\n      }\n      return 'TEXT';\n    }\n  }\n\n  BaseTypes.TEXT.types.postgres = ['text'];\n\n  class CITEXT extends BaseTypes.CITEXT {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.CITEXT.types.postgres = ['citext'];\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        return 'BYTEA';\n      }\n      return super.toSql();\n    }\n  }\n\n  BaseTypes.CHAR.types.postgres = ['char', 'bpchar'];\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'BOOLEAN';\n    }\n    _sanitize(value) {\n      if (value !== null && value !== undefined) {\n        if (Buffer.isBuffer(value) && value.length === 1) {\n          // Bit fields are returned as buffers\n          value = value[0];\n        }\n        if (typeof value === 'string') {\n          // Only take action on valid boolean strings.\n          return value === 'true' || value === 't' ? true : value === 'false' || value === 'f' ? false : value;\n        }\n        if (typeof value === 'number') {\n          // Only take action on valid boolean integers.\n          return value === 1 ? true : value === 0 ? false : value;\n        }\n      }\n      return value;\n    }\n  }\n\n  BOOLEAN.parse = BOOLEAN.prototype._sanitize;\n\n  BaseTypes.BOOLEAN.types.postgres = ['bool'];\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH TIME ZONE';\n    }\n    validate(value) {\n      if (value !== Infinity && value !== -Infinity) {\n        return super.validate(value);\n      }\n      return true;\n    }\n    _stringify(value, options) {\n      if (value === Infinity) {\n        return 'Infinity';\n      }\n      if (value === -Infinity) {\n        return '-Infinity';\n      }\n      return super._stringify(value, options);\n    }\n    _sanitize(value, options) {\n      if ((!options || options && !options.raw) && !(value instanceof Date) && !!value && value !== Infinity && value !== -Infinity) {\n        if (typeof value === 'string') {\n          const lower = value.toLowerCase();\n          if (lower === 'infinity') {\n            return Infinity;\n          }\n          if (lower === '-infinity') {\n            return -Infinity;\n          }\n        }\n        return new Date(value);\n      }\n      return value;\n    }\n  }\n\n  BaseTypes.DATE.types.postgres = ['timestamptz'];\n\n  class TINYINT extends BaseTypes.TINYINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.TINYINT.types.postgres = ['int2'];\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int2\n  BaseTypes.SMALLINT.types.postgres = ['int2'];\n\n  class INTEGER extends BaseTypes.INTEGER {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  INTEGER.parse = function parse(value) {\n    return parseInt(value, 10);\n  };\n\n  // int4\n  BaseTypes.INTEGER.types.postgres = ['int4'];\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // int8\n  BaseTypes.BIGINT.types.postgres = ['int8'];\n\n  class REAL extends BaseTypes.REAL {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float4\n  BaseTypes.REAL.types.postgres = ['float4'];\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length) {\n      super(length);\n      removeUnsupportedIntegerOptions(this);\n    }\n  }\n  // float8\n  BaseTypes.DOUBLE.types.postgres = ['float8'];\n\n  class FLOAT extends BaseTypes.FLOAT {\n    constructor(length, decimals) {\n      super(length, decimals);\n      // POSTGRES does only support lengths as parameter.\n      // Values between 1-24 result in REAL\n      // Values between 25-53 result in DOUBLE PRECISION\n      // If decimals are provided remove these and print a warning\n      if (this._decimals) {\n        warn('PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._decimals = undefined;\n      }\n      if (this._unsigned) {\n        warn('PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed.');\n        this._unsigned = undefined;\n      }\n      if (this._zerofill) {\n        warn('PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed.');\n        this._zerofill = undefined;\n      }\n    }\n  }\n  delete FLOAT.parse; // Float has no separate type in PG\n\n  class BLOB extends BaseTypes.BLOB {\n    toSql() {\n      if (this._length) {\n        warn('PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead.');\n        this._length = undefined;\n      }\n      return 'BYTEA';\n    }\n    _hexify(hex) {\n      // bytea hex format http://www.postgresql.org/docs/current/static/datatype-binary.html\n      return `E'\\\\\\\\x${hex}'`;\n    }\n  }\n\n  BaseTypes.BLOB.types.postgres = ['bytea'];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    toSql() {\n      let result = this.key;\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    _bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOMETRY.types.postgres = ['geometry'];\n\n\n  class GEOGRAPHY extends BaseTypes.GEOGRAPHY {\n    toSql() {\n      let result = 'GEOGRAPHY';\n      if (this.type) {\n        result += `(${this.type}`;\n        if (this.srid) {\n          result += `,${this.srid}`;\n        }\n        result += ')';\n      }\n      return result;\n    }\n    static parse(value) {\n      const b = Buffer.from(value, 'hex');\n      return wkx.Geometry.parse(b).toGeoJSON({ shortCrs: true });\n    }\n    _stringify(value, options) {\n      return `ST_GeomFromGeoJSON(${options.escape(JSON.stringify(value))})`;\n    }\n    bindParam(value, options) {\n      return `ST_GeomFromGeoJSON(${options.bindParam(value)})`;\n    }\n  }\n\n  BaseTypes.GEOGRAPHY.types.postgres = ['geography'];\n\n  let hstore;\n\n  class HSTORE extends BaseTypes.HSTORE {\n    constructor() {\n      super();\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n    }\n    _value(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.stringify(value);\n    }\n    _stringify(value) {\n      return `'${this._value(value)}'`;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(this._value(value));\n    }\n    static parse(value) {\n      if (!hstore) {\n        // All datatype files are loaded at import - make sure we don't load the hstore parser before a hstore is instantiated\n        hstore = require('./hstore');\n      }\n      return hstore.parse(value);\n    }\n  }\n\n  HSTORE.prototype.escape = false;\n\n  BaseTypes.HSTORE.types.postgres = ['hstore'];\n\n  class RANGE extends BaseTypes.RANGE {\n    _value(values, options) {\n      if (!Array.isArray(values)) {\n        return this.options.subtype.stringify(values, options);\n      }\n      const valueInclusivity = [true, false];\n      const valuesStringified = values.map((value, index) => {\n        if (_.isObject(value) && Object.prototype.hasOwnProperty.call(value, 'value')) {\n          if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) {\n            valueInclusivity[index] = value.inclusive;\n          }\n          value = value.value;\n        }\n        if (value === null || value === -Infinity || value === Infinity) {\n          // Pass through \"unbounded\" bounds unchanged\n          return value;\n        }\n        if (this.options.subtype.stringify) {\n          return this.options.subtype.stringify(value, options);\n        }\n        return options.escape(value);\n      });\n      // Array.map does not preserve extra array properties\n      valuesStringified.inclusive = valueInclusivity;\n      return range.stringify(valuesStringified);\n    }\n    _stringify(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `'${value}'::${this.toCastType()}`;\n      }\n      return `'${value}'`;\n    }\n    _bindParam(values, options) {\n      const value = this._value(values, options);\n      if (!Array.isArray(values)) {\n        return `${options.bindParam(value)}::${this.toCastType()}`;\n      }\n      return options.bindParam(value);\n    }\n    toSql() {\n      return BaseTypes.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()];\n    }\n    toCastType() {\n      return BaseTypes.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()];\n    }\n    static parse(value, options = { parser: val => val }) {\n      return range.parse(value, options.parser);\n    }\n  }\n  const range = require('./range');\n\n  RANGE.prototype.escape = false;\n\n  BaseTypes.RANGE.types.postgres = {\n    subtypes: {\n      integer: 'int4range',\n      decimal: 'numrange',\n      date: 'tstzrange',\n      dateonly: 'daterange',\n      bigint: 'int8range'\n    },\n    castTypes: {\n      integer: 'int4',\n      decimal: 'numeric',\n      date: 'timestamptz',\n      dateonly: 'date',\n      bigint: 'int8'\n    }\n  };\n\n  // TODO: Why are base types being manipulated??\n  BaseTypes.ARRAY.prototype.escape = false;\n  BaseTypes.ARRAY.prototype._value = function _value(values, options) {\n    return values.map(value => {\n      if (options && options.bindParam && this.type && this.type._value) {\n        return this.type._value(value, options);\n      }\n      if (this.type && this.type.stringify) {\n        value = this.type.stringify(value, options);\n\n        if (this.type.escape === false) {\n          return value;\n        }\n      }\n      return options.escape(value);\n    }, this);\n  };\n  BaseTypes.ARRAY.prototype._stringify = function _stringify(values, options) {\n    let str = `ARRAY[${this._value(values, options).join(',')}]`;\n\n    if (this.type) {\n      const Utils = require('../../utils');\n      let castKey = this.toSql();\n\n      if (this.type instanceof BaseTypes.ENUM) {\n        castKey = `${Utils.addTicks(\n          Utils.generateEnumName(options.field.Model.getTableName(), options.field.fieldName),\n          '\"'\n        ) }[]`;\n      }\n\n      str += `::${castKey}`;\n    }\n\n    return str;\n  };\n  BaseTypes.ARRAY.prototype._bindParam = function _bindParam(values, options) {\n    return options.bindParam(this._value(values, options));\n  };\n\n  class ENUM extends BaseTypes.ENUM {\n    static parse(value) {\n      return value;\n    }\n  }\n\n  BaseTypes.ENUM.types.postgres = [null];\n\n  return {\n    DECIMAL,\n    BLOB,\n    STRING,\n    CHAR,\n    TEXT,\n    CITEXT,\n    TINYINT,\n    SMALLINT,\n    INTEGER,\n    BIGINT,\n    BOOLEAN,\n    DATE,\n    DATEONLY,\n    REAL,\n    'DOUBLE PRECISION': DOUBLE,\n    FLOAT,\n    GEOMETRY,\n    GEOGRAPHY,\n    HSTORE,\n    RANGE,\n    ENUM\n  };\n};\n"]},"metadata":{},"sourceType":"script"}