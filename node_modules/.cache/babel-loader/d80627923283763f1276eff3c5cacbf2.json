{"ast":null,"code":"'use strict';\n/**\n * The transaction object is used to identify a running transaction.\n * It is created by calling `Sequelize.transaction()`.\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @class Transaction\n * @see {@link Sequelize.transaction}\n */\n\nclass Transaction {\n  /**\n   * Creates a new transaction instance\n   *\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {object} options An object with options\n   * @param {string} [options.type] Sets the type of the transaction. Sqlite only\n   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.\n   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = []; // get dialect specific transaction options\n\n    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;\n    this.options = {\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false,\n      ...options\n    };\n    this.parent = this.options.transaction;\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n  /**\n   * Commit the transaction\n   *\n   * @returns {Promise}\n   */\n\n\n  async commit() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n    }\n\n    try {\n      return await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n    } finally {\n      this.finished = 'commit';\n      this.cleanup();\n\n      for (const hook of this._afterCommitHooks) {\n        await hook.apply(this, [this]);\n      }\n    }\n  }\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @returns {Promise}\n   */\n\n\n  async rollback() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    }\n\n    if (!this.connection) {\n      throw new Error('Transaction cannot be rolled back because it never started');\n    }\n\n    try {\n      return await this.sequelize.getQueryInterface().rollbackTransaction(this, this.options);\n    } finally {\n      this.cleanup();\n    }\n  }\n  /**\n   * Called to acquire a connection to use and set the correct options on the connection.\n   * We should ensure all of the environment that's set up is cleaned up in `cleanup()` below.\n   *\n   * @param {boolean} useCLS Defaults to true: Use CLS (Continuation Local Storage) with Sequelize. With CLS, all queries within the transaction callback will automatically receive the transaction object.\n   * @returns {Promise}\n   */\n\n\n  async prepareEnvironment(useCLS) {\n    let connectionPromise;\n\n    if (useCLS === undefined) {\n      useCLS = true;\n    }\n\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = {\n        uuid: this.id\n      };\n\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    let result;\n    const connection = await connectionPromise;\n    this.connection = connection;\n    this.connection.uuid = this.id;\n\n    try {\n      await this.begin();\n      result = await this.setDeferrable();\n    } catch (setupErr) {\n      try {\n        result = await this.rollback();\n      } finally {\n        throw setupErr; // eslint-disable-line no-unsafe-finally\n      }\n    }\n\n    if (useCLS && this.sequelize.constructor._cls) {\n      this.sequelize.constructor._cls.set('transaction', this);\n    }\n\n    return result;\n  }\n\n  async setDeferrable() {\n    if (this.options.deferrable) {\n      return await this.sequelize.getQueryInterface().deferConstraints(this, this.options);\n    }\n  }\n\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n\n    if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {\n      await queryInterface.startTransaction(this, this.options);\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    return queryInterface.startTransaction(this, this.options);\n  }\n\n  cleanup() {\n    // Don't release the connection if there's a parent transaction or\n    // if we've already cleaned up\n    if (this.parent || this.connection.uuid === undefined) return;\n\n    this._clearCls();\n\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n\n\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n\n    this._afterCommitHooks.push(fn);\n  }\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {\n   *      // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n\n\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n  /**\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n   *     // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n\n\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * @example\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   *\n   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   *\n   * # UserModel will be locked but TaskModel won't!\n   *\n   * @example <caption>You can also skip locked rows:</caption>\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: true,\n   *   skipLocked: true\n   * });\n   * # The query will now return any rows that aren't locked by another transaction\n   *\n   * @returns {object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n\n\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n  /**\n   * Please see {@link Transaction.LOCK}\n   */\n\n\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;","map":{"version":3,"sources":["/Users/albab/bookapro/amazon/node_modules/sequelize/lib/transaction.js"],"names":["Transaction","constructor","sequelize","options","savepoints","_afterCommitHooks","generateTransactionId","dialect","queryGenerator","type","transactionType","isolationLevel","readOnly","parent","transaction","id","push","name","length","commit","finished","Error","getQueryInterface","commitTransaction","cleanup","hook","apply","rollback","connection","rollbackTransaction","prepareEnvironment","useCLS","connectionPromise","undefined","Promise","resolve","acquireOptions","uuid","connectionManager","getConnection","result","begin","setDeferrable","setupErr","_cls","set","deferrable","deferConstraints","queryInterface","supports","settingIsolationLevelDuringTransaction","startTransaction","setIsolationLevel","_clearCls","res","releaseConnection","cls","get","afterCommit","fn","TYPES","DEFERRED","IMMEDIATE","EXCLUSIVE","ISOLATION_LEVELS","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","SERIALIZABLE","LOCK","UPDATE","SHARE","KEY_SHARE","NO_KEY_UPDATE","module","exports","default"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * The transaction object is used to identify a running transaction.\n * It is created by calling `Sequelize.transaction()`.\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @class Transaction\n * @see {@link Sequelize.transaction}\n */\nclass Transaction {\n  /**\n   * Creates a new transaction instance\n   *\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {object} options An object with options\n   * @param {string} [options.type] Sets the type of the transaction. Sqlite only\n   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.\n   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n\n    // get dialect specific transaction options\n    const generateTransactionId = this.sequelize.dialect.queryGenerator.generateTransactionId;\n\n    this.options = {\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false,\n      ...options\n    };\n\n    this.parent = this.options.transaction;\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n\n  /**\n   * Commit the transaction\n   *\n   * @returns {Promise}\n   */\n  async commit() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);\n    }\n\n    try {\n      return await this.sequelize.getQueryInterface().commitTransaction(this, this.options);\n    } finally {\n      this.finished = 'commit';\n      this.cleanup();\n      for (const hook of this._afterCommitHooks) {\n        await hook.apply(this, [this]);\n      }\n    }\n  }\n\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @returns {Promise}\n   */\n  async rollback() {\n    if (this.finished) {\n      throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);\n    }\n\n    if (!this.connection) {\n      throw new Error('Transaction cannot be rolled back because it never started');\n    }\n\n    try {\n      return await this\n        .sequelize\n        .getQueryInterface()\n        .rollbackTransaction(this, this.options);\n    } finally {\n      this.cleanup();\n    }\n  }\n\n  /**\n   * Called to acquire a connection to use and set the correct options on the connection.\n   * We should ensure all of the environment that's set up is cleaned up in `cleanup()` below.\n   *\n   * @param {boolean} useCLS Defaults to true: Use CLS (Continuation Local Storage) with Sequelize. With CLS, all queries within the transaction callback will automatically receive the transaction object.\n   * @returns {Promise}\n   */\n  async prepareEnvironment(useCLS) {\n    let connectionPromise;\n\n    if (useCLS === undefined) {\n      useCLS = true;\n    }\n\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    let result;\n    const connection = await connectionPromise;\n    this.connection = connection;\n    this.connection.uuid = this.id;\n\n    try {\n      await this.begin();\n      result = await this.setDeferrable();\n    } catch (setupErr) {\n      try {\n        result = await this.rollback();\n      } finally {\n        throw setupErr; // eslint-disable-line no-unsafe-finally\n      }\n    }\n\n    if (useCLS && this.sequelize.constructor._cls) {\n      this.sequelize.constructor._cls.set('transaction', this);\n    }\n\n    return result;\n  }\n\n  async setDeferrable() {\n    if (this.options.deferrable) {\n      return await this\n        .sequelize\n        .getQueryInterface()\n        .deferConstraints(this, this.options);\n    }\n  }\n\n  async begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n\n    if ( this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ) {\n      await queryInterface.startTransaction(this, this.options);\n      return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n    }\n\n    await queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n\n    return queryInterface.startTransaction(this, this.options);\n  }\n\n  cleanup() {\n    // Don't release the connection if there's a parent transaction or\n    // if we've already cleaned up\n    if (this.parent || this.connection.uuid === undefined) return;\n\n    this._clearCls();\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   await sequelize.transaction({ type: Sequelize.Transaction.TYPES.EXCLUSIVE }, transaction => {\n   *      // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n\n  /**\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * try {\n   *   const result = await sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n   *     // your transactions\n   *   });\n   *   // transaction has been committed. Do something after the commit if required.\n   * } catch(err) {\n   *   // do something with the err.\n   * }\n   *\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n\n\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * @example\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   *\n   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   *\n   * # UserModel will be locked but TaskModel won't!\n   *\n   * @example <caption>You can also skip locked rows:</caption>\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: true,\n   *   skipLocked: true\n   * });\n   * # The query will now return any rows that aren't locked by another transaction\n   *\n   * @returns {object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n\n  /**\n   * Please see {@link Transaction.LOCK}\n   */\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;\n"]},"metadata":{},"sourceType":"script"}