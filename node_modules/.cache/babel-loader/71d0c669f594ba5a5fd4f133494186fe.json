{"ast":null,"code":"import clone from 'clone';\nimport equal from 'deep-equal';\nimport extend from 'extend';\nimport Delta from 'quill-delta';\nimport DeltaOp from 'quill-delta/lib/op';\nimport Parchment from 'parchment';\nimport Quill from '../core/quill';\nimport logger from '../core/logger';\nimport Module from '../core/module';\nlet debug = logger('quill:keyboard');\nconst SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';\n\nclass Keyboard extends Module {\n  static match(evt, binding) {\n    binding = normalize(binding);\n\n    if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {\n      return !!binding[key] !== evt[key] && binding[key] !== null;\n    })) {\n      return false;\n    }\n\n    return binding.key === (evt.which || evt.keyCode);\n  }\n\n  constructor(quill, options) {\n    super(quill, options);\n    this.bindings = {};\n    Object.keys(this.options.bindings).forEach(name => {\n      if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {\n        return;\n      }\n\n      if (this.options.bindings[name]) {\n        this.addBinding(this.options.bindings[name]);\n      }\n    });\n    this.addBinding({\n      key: Keyboard.keys.ENTER,\n      shiftKey: null\n    }, handleEnter);\n    this.addBinding({\n      key: Keyboard.keys.ENTER,\n      metaKey: null,\n      ctrlKey: null,\n      altKey: null\n    }, function () {});\n\n    if (/Firefox/i.test(navigator.userAgent)) {\n      // Need to handle delete and backspace for Firefox in the general case #1171\n      this.addBinding({\n        key: Keyboard.keys.BACKSPACE\n      }, {\n        collapsed: true\n      }, handleBackspace);\n      this.addBinding({\n        key: Keyboard.keys.DELETE\n      }, {\n        collapsed: true\n      }, handleDelete);\n    } else {\n      this.addBinding({\n        key: Keyboard.keys.BACKSPACE\n      }, {\n        collapsed: true,\n        prefix: /^.?$/\n      }, handleBackspace);\n      this.addBinding({\n        key: Keyboard.keys.DELETE\n      }, {\n        collapsed: true,\n        suffix: /^.?$/\n      }, handleDelete);\n    }\n\n    this.addBinding({\n      key: Keyboard.keys.BACKSPACE\n    }, {\n      collapsed: false\n    }, handleDeleteRange);\n    this.addBinding({\n      key: Keyboard.keys.DELETE\n    }, {\n      collapsed: false\n    }, handleDeleteRange);\n    this.addBinding({\n      key: Keyboard.keys.BACKSPACE,\n      altKey: null,\n      ctrlKey: null,\n      metaKey: null,\n      shiftKey: null\n    }, {\n      collapsed: true,\n      offset: 0\n    }, handleBackspace);\n    this.listen();\n  }\n\n  addBinding(key, context = {}, handler = {}) {\n    let binding = normalize(key);\n\n    if (binding == null || binding.key == null) {\n      return debug.warn('Attempted to add invalid keyboard binding', binding);\n    }\n\n    if (typeof context === 'function') {\n      context = {\n        handler: context\n      };\n    }\n\n    if (typeof handler === 'function') {\n      handler = {\n        handler: handler\n      };\n    }\n\n    binding = extend(binding, context, handler);\n    this.bindings[binding.key] = this.bindings[binding.key] || [];\n    this.bindings[binding.key].push(binding);\n  }\n\n  listen() {\n    this.quill.root.addEventListener('keydown', evt => {\n      if (evt.defaultPrevented) return;\n      let which = evt.which || evt.keyCode;\n      let bindings = (this.bindings[which] || []).filter(function (binding) {\n        return Keyboard.match(evt, binding);\n      });\n      if (bindings.length === 0) return;\n      let range = this.quill.getSelection();\n      if (range == null || !this.quill.hasFocus()) return;\n      let [line, offset] = this.quill.getLine(range.index);\n      let [leafStart, offsetStart] = this.quill.getLeaf(range.index);\n      let [leafEnd, offsetEnd] = range.length === 0 ? [leafStart, offsetStart] : this.quill.getLeaf(range.index + range.length);\n      let prefixText = leafStart instanceof Parchment.Text ? leafStart.value().slice(0, offsetStart) : '';\n      let suffixText = leafEnd instanceof Parchment.Text ? leafEnd.value().slice(offsetEnd) : '';\n      let curContext = {\n        collapsed: range.length === 0,\n        empty: range.length === 0 && line.length() <= 1,\n        format: this.quill.getFormat(range),\n        offset: offset,\n        prefix: prefixText,\n        suffix: suffixText\n      };\n      let prevented = bindings.some(binding => {\n        if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;\n        if (binding.empty != null && binding.empty !== curContext.empty) return false;\n        if (binding.offset != null && binding.offset !== curContext.offset) return false;\n\n        if (Array.isArray(binding.format)) {\n          // any format is present\n          if (binding.format.every(function (name) {\n            return curContext.format[name] == null;\n          })) {\n            return false;\n          }\n        } else if (typeof binding.format === 'object') {\n          // all formats must match\n          if (!Object.keys(binding.format).every(function (name) {\n            if (binding.format[name] === true) return curContext.format[name] != null;\n            if (binding.format[name] === false) return curContext.format[name] == null;\n            return equal(binding.format[name], curContext.format[name]);\n          })) {\n            return false;\n          }\n        }\n\n        if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;\n        if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;\n        return binding.handler.call(this, range, curContext) !== true;\n      });\n\n      if (prevented) {\n        evt.preventDefault();\n      }\n    });\n  }\n\n}\n\nKeyboard.keys = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  ESCAPE: 27,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  DELETE: 46\n};\nKeyboard.DEFAULTS = {\n  bindings: {\n    'bold': makeFormatHandler('bold'),\n    'italic': makeFormatHandler('italic'),\n    'underline': makeFormatHandler('underline'),\n    'indent': {\n      // highlight tab or tab at beginning of list, indent or blockquote\n      key: Keyboard.keys.TAB,\n      format: ['blockquote', 'indent', 'list'],\n      handler: function (range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '+1', Quill.sources.USER);\n      }\n    },\n    'outdent': {\n      key: Keyboard.keys.TAB,\n      shiftKey: true,\n      format: ['blockquote', 'indent', 'list'],\n      // highlight tab or tab at beginning of list, indent or blockquote\n      handler: function (range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '-1', Quill.sources.USER);\n      }\n    },\n    'outdent backspace': {\n      key: Keyboard.keys.BACKSPACE,\n      collapsed: true,\n      shiftKey: null,\n      metaKey: null,\n      ctrlKey: null,\n      altKey: null,\n      format: ['indent', 'list'],\n      offset: 0,\n      handler: function (range, context) {\n        if (context.format.indent != null) {\n          this.quill.format('indent', '-1', Quill.sources.USER);\n        } else if (context.format.list != null) {\n          this.quill.format('list', false, Quill.sources.USER);\n        }\n      }\n    },\n    'indent code-block': makeCodeBlockHandler(true),\n    'outdent code-block': makeCodeBlockHandler(false),\n    'remove tab': {\n      key: Keyboard.keys.TAB,\n      shiftKey: true,\n      collapsed: true,\n      prefix: /\\t$/,\n      handler: function (range) {\n        this.quill.deleteText(range.index - 1, 1, Quill.sources.USER);\n      }\n    },\n    'tab': {\n      key: Keyboard.keys.TAB,\n      handler: function (range) {\n        this.quill.history.cutoff();\n        let delta = new Delta().retain(range.index).delete(range.length).insert('\\t');\n        this.quill.updateContents(delta, Quill.sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);\n      }\n    },\n    'list empty enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['list'],\n      empty: true,\n      handler: function (range, context) {\n        this.quill.format('list', false, Quill.sources.USER);\n\n        if (context.format.indent) {\n          this.quill.format('indent', false, Quill.sources.USER);\n        }\n      }\n    },\n    'checklist enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: {\n        list: 'checked'\n      },\n      handler: function (range) {\n        let [line, offset] = this.quill.getLine(range.index);\n        let formats = extend({}, line.formats(), {\n          list: 'checked'\n        });\n        let delta = new Delta().retain(range.index).insert('\\n', formats).retain(line.length() - offset - 1).retain(1, {\n          list: 'unchecked'\n        });\n        this.quill.updateContents(delta, Quill.sources.USER);\n        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'header enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['header'],\n      suffix: /^$/,\n      handler: function (range, context) {\n        let [line, offset] = this.quill.getLine(range.index);\n        let delta = new Delta().retain(range.index).insert('\\n', context.format).retain(line.length() - offset - 1).retain(1, {\n          header: null\n        });\n        this.quill.updateContents(delta, Quill.sources.USER);\n        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'list autofill': {\n      key: ' ',\n      collapsed: true,\n      format: {\n        list: false\n      },\n      prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n      handler: function (range, context) {\n        let length = context.prefix.length;\n        let [line, offset] = this.quill.getLine(range.index);\n        if (offset > length) return true;\n        let value;\n\n        switch (context.prefix.trim()) {\n          case '[]':\n          case '[ ]':\n            value = 'unchecked';\n            break;\n\n          case '[x]':\n            value = 'checked';\n            break;\n\n          case '-':\n          case '*':\n            value = 'bullet';\n            break;\n\n          default:\n            value = 'ordered';\n        }\n\n        this.quill.insertText(range.index, ' ', Quill.sources.USER);\n        this.quill.history.cutoff();\n        let delta = new Delta().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {\n          list: value\n        });\n        this.quill.updateContents(delta, Quill.sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index - length, Quill.sources.SILENT);\n      }\n    },\n    'code exit': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['code-block'],\n      prefix: /\\n\\n$/,\n      suffix: /^\\s+$/,\n      handler: function (range) {\n        const [line, offset] = this.quill.getLine(range.index);\n        const delta = new Delta().retain(range.index + line.length() - offset - 2).retain(1, {\n          'code-block': null\n        }).delete(1);\n        this.quill.updateContents(delta, Quill.sources.USER);\n      }\n    },\n    'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),\n    'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),\n    'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),\n    'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)\n  }\n};\n\nfunction makeEmbedArrowHandler(key, shiftKey) {\n  const where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';\n  return {\n    key,\n    shiftKey,\n    altKey: null,\n    [where]: /^$/,\n    handler: function (range) {\n      let index = range.index;\n\n      if (key === Keyboard.keys.RIGHT) {\n        index += range.length + 1;\n      }\n\n      const [leaf] = this.quill.getLeaf(index);\n      if (!(leaf instanceof Parchment.Embed)) return true;\n\n      if (key === Keyboard.keys.LEFT) {\n        if (shiftKey) {\n          this.quill.setSelection(range.index - 1, range.length + 1, Quill.sources.USER);\n        } else {\n          this.quill.setSelection(range.index - 1, Quill.sources.USER);\n        }\n      } else {\n        if (shiftKey) {\n          this.quill.setSelection(range.index, range.length + 1, Quill.sources.USER);\n        } else {\n          this.quill.setSelection(range.index + range.length + 1, Quill.sources.USER);\n        }\n      }\n\n      return false;\n    }\n  };\n}\n\nfunction handleBackspace(range, context) {\n  if (range.index === 0 || this.quill.getLength() <= 1) return;\n  let [line] = this.quill.getLine(range.index);\n  let formats = {};\n\n  if (context.offset === 0) {\n    let [prev] = this.quill.getLine(range.index - 1);\n\n    if (prev != null && prev.length() > 1) {\n      let curFormats = line.formats();\n      let prevFormats = this.quill.getFormat(range.index - 1, 1);\n      formats = DeltaOp.attributes.diff(curFormats, prevFormats) || {};\n    }\n  } // Check for astral symbols\n\n\n  let length = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(context.prefix) ? 2 : 1;\n  this.quill.deleteText(range.index - length, length, Quill.sources.USER);\n\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index - length, length, formats, Quill.sources.USER);\n  }\n\n  this.quill.focus();\n}\n\nfunction handleDelete(range, context) {\n  // Check for astral symbols\n  let length = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(context.suffix) ? 2 : 1;\n  if (range.index >= this.quill.getLength() - length) return;\n  let formats = {},\n      nextLength = 0;\n  let [line] = this.quill.getLine(range.index);\n\n  if (context.offset >= line.length() - 1) {\n    let [next] = this.quill.getLine(range.index + 1);\n\n    if (next) {\n      let curFormats = line.formats();\n      let nextFormats = this.quill.getFormat(range.index, 1);\n      formats = DeltaOp.attributes.diff(curFormats, nextFormats) || {};\n      nextLength = next.length();\n    }\n  }\n\n  this.quill.deleteText(range.index, length, Quill.sources.USER);\n\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index + nextLength - 1, length, formats, Quill.sources.USER);\n  }\n}\n\nfunction handleDeleteRange(range) {\n  let lines = this.quill.getLines(range);\n  let formats = {};\n\n  if (lines.length > 1) {\n    let firstFormats = lines[0].formats();\n    let lastFormats = lines[lines.length - 1].formats();\n    formats = DeltaOp.attributes.diff(lastFormats, firstFormats) || {};\n  }\n\n  this.quill.deleteText(range, Quill.sources.USER);\n\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index, 1, formats, Quill.sources.USER);\n  }\n\n  this.quill.setSelection(range.index, Quill.sources.SILENT);\n  this.quill.focus();\n}\n\nfunction handleEnter(range, context) {\n  if (range.length > 0) {\n    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change\n  }\n\n  let lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {\n    if (Parchment.query(format, Parchment.Scope.BLOCK) && !Array.isArray(context.format[format])) {\n      lineFormats[format] = context.format[format];\n    }\n\n    return lineFormats;\n  }, {});\n  this.quill.insertText(range.index, '\\n', lineFormats, Quill.sources.USER); // Earlier scroll.deleteAt might have messed up our selection,\n  // so insertText's built in selection preservation is not reliable\n\n  this.quill.setSelection(range.index + 1, Quill.sources.SILENT);\n  this.quill.focus();\n  Object.keys(context.format).forEach(name => {\n    if (lineFormats[name] != null) return;\n    if (Array.isArray(context.format[name])) return;\n    if (name === 'link') return;\n    this.quill.format(name, context.format[name], Quill.sources.USER);\n  });\n}\n\nfunction makeCodeBlockHandler(indent) {\n  return {\n    key: Keyboard.keys.TAB,\n    shiftKey: !indent,\n    format: {\n      'code-block': true\n    },\n    handler: function (range) {\n      let CodeBlock = Parchment.query('code-block');\n      let index = range.index,\n          length = range.length;\n      let [block, offset] = this.quill.scroll.descendant(CodeBlock, index);\n      if (block == null) return;\n      let scrollIndex = this.quill.getIndex(block);\n      let start = block.newlineIndex(offset, true) + 1;\n      let end = block.newlineIndex(scrollIndex + offset + length);\n      let lines = block.domNode.textContent.slice(start, end).split('\\n');\n      offset = 0;\n      lines.forEach((line, i) => {\n        if (indent) {\n          block.insertAt(start + offset, CodeBlock.TAB);\n          offset += CodeBlock.TAB.length;\n\n          if (i === 0) {\n            index += CodeBlock.TAB.length;\n          } else {\n            length += CodeBlock.TAB.length;\n          }\n        } else if (line.startsWith(CodeBlock.TAB)) {\n          block.deleteAt(start + offset, CodeBlock.TAB.length);\n          offset -= CodeBlock.TAB.length;\n\n          if (i === 0) {\n            index -= CodeBlock.TAB.length;\n          } else {\n            length -= CodeBlock.TAB.length;\n          }\n        }\n\n        offset += line.length + 1;\n      });\n      this.quill.update(Quill.sources.USER);\n      this.quill.setSelection(index, length, Quill.sources.SILENT);\n    }\n  };\n}\n\nfunction makeFormatHandler(format) {\n  return {\n    key: format[0].toUpperCase(),\n    shortKey: true,\n    handler: function (range, context) {\n      this.quill.format(format, !context.format[format], Quill.sources.USER);\n    }\n  };\n}\n\nfunction normalize(binding) {\n  if (typeof binding === 'string' || typeof binding === 'number') {\n    return normalize({\n      key: binding\n    });\n  }\n\n  if (typeof binding === 'object') {\n    binding = clone(binding, false);\n  }\n\n  if (typeof binding.key === 'string') {\n    if (Keyboard.keys[binding.key.toUpperCase()] != null) {\n      binding.key = Keyboard.keys[binding.key.toUpperCase()];\n    } else if (binding.key.length === 1) {\n      binding.key = binding.key.toUpperCase().charCodeAt(0);\n    } else {\n      return null;\n    }\n  }\n\n  if (binding.shortKey) {\n    binding[SHORTKEY] = binding.shortKey;\n    delete binding.shortKey;\n  }\n\n  return binding;\n}\n\nexport { Keyboard as default, SHORTKEY };","map":{"version":3,"sources":["/Users/albab/bookapro/amazon/src/assets/vendor/quill/modules/keyboard.js"],"names":["clone","equal","extend","Delta","DeltaOp","Parchment","Quill","logger","Module","debug","SHORTKEY","test","navigator","platform","Keyboard","match","evt","binding","normalize","some","key","which","keyCode","constructor","quill","options","bindings","Object","keys","forEach","name","scroll","whitelist","addBinding","ENTER","shiftKey","handleEnter","metaKey","ctrlKey","altKey","userAgent","BACKSPACE","collapsed","handleBackspace","DELETE","handleDelete","prefix","suffix","handleDeleteRange","offset","listen","context","handler","warn","push","root","addEventListener","defaultPrevented","filter","length","range","getSelection","hasFocus","line","getLine","index","leafStart","offsetStart","getLeaf","leafEnd","offsetEnd","prefixText","Text","value","slice","suffixText","curContext","empty","format","getFormat","prevented","Array","isArray","every","call","preventDefault","TAB","ESCAPE","LEFT","UP","RIGHT","DOWN","DEFAULTS","makeFormatHandler","sources","USER","indent","list","makeCodeBlockHandler","deleteText","history","cutoff","delta","retain","delete","insert","updateContents","setSelection","SILENT","formats","scrollIntoView","header","trim","insertText","makeEmbedArrowHandler","where","leaf","Embed","getLength","prev","curFormats","prevFormats","attributes","diff","formatLine","focus","nextLength","next","nextFormats","lines","getLines","firstFormats","lastFormats","deleteAt","lineFormats","reduce","query","Scope","BLOCK","CodeBlock","block","descendant","scrollIndex","getIndex","start","newlineIndex","end","domNode","textContent","split","i","insertAt","startsWith","update","toUpperCase","shortKey","charCodeAt","default"],"mappings":"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","sourcesContent":["import clone from 'clone';\nimport equal from 'deep-equal';\nimport extend from 'extend';\nimport Delta from 'quill-delta';\nimport DeltaOp from 'quill-delta/lib/op';\nimport Parchment from 'parchment';\nimport Quill from '../core/quill';\nimport logger from '../core/logger';\nimport Module from '../core/module';\n\nlet debug = logger('quill:keyboard');\n\nconst SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';\n\n\nclass Keyboard extends Module {\n  static match(evt, binding) {\n    binding = normalize(binding);\n    if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function(key) {\n      return (!!binding[key] !== evt[key] && binding[key] !== null);\n    })) {\n      return false;\n    }\n    return binding.key === (evt.which || evt.keyCode);\n  }\n\n  constructor(quill, options) {\n    super(quill, options);\n    this.bindings = {};\n    Object.keys(this.options.bindings).forEach((name) => {\n      if (name === 'list autofill' &&\n          quill.scroll.whitelist != null &&\n          !quill.scroll.whitelist['list']) {\n        return;\n      }\n      if (this.options.bindings[name]) {\n        this.addBinding(this.options.bindings[name]);\n      }\n    });\n    this.addBinding({ key: Keyboard.keys.ENTER, shiftKey: null }, handleEnter);\n    this.addBinding({ key: Keyboard.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function() {});\n    if (/Firefox/i.test(navigator.userAgent)) {\n      // Need to handle delete and backspace for Firefox in the general case #1171\n      this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true }, handleBackspace);\n      this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true }, handleDelete);\n    } else {\n      this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);\n      this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);\n    }\n    this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);\n    this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: false }, handleDeleteRange);\n    this.addBinding({ key: Keyboard.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null },\n                    { collapsed: true, offset: 0 },\n                    handleBackspace);\n    this.listen();\n  }\n\n  addBinding(key, context = {}, handler = {}) {\n    let binding = normalize(key);\n    if (binding == null || binding.key == null) {\n      return debug.warn('Attempted to add invalid keyboard binding', binding);\n    }\n    if (typeof context === 'function') {\n      context = { handler: context };\n    }\n    if (typeof handler === 'function') {\n      handler = { handler: handler };\n    }\n    binding = extend(binding, context, handler);\n    this.bindings[binding.key] = this.bindings[binding.key] || [];\n    this.bindings[binding.key].push(binding);\n  }\n\n  listen() {\n    this.quill.root.addEventListener('keydown', (evt) => {\n      if (evt.defaultPrevented) return;\n      let which = evt.which || evt.keyCode;\n      let bindings = (this.bindings[which] || []).filter(function(binding) {\n        return Keyboard.match(evt, binding);\n      });\n      if (bindings.length === 0) return;\n      let range = this.quill.getSelection();\n      if (range == null || !this.quill.hasFocus()) return;\n      let [line, offset] = this.quill.getLine(range.index);\n      let [leafStart, offsetStart] = this.quill.getLeaf(range.index);\n      let [leafEnd, offsetEnd] = range.length === 0 ? [leafStart, offsetStart] : this.quill.getLeaf(range.index + range.length);\n      let prefixText = leafStart instanceof Parchment.Text ? leafStart.value().slice(0, offsetStart) : '';\n      let suffixText = leafEnd instanceof Parchment.Text ? leafEnd.value().slice(offsetEnd) : '';\n      let curContext = {\n        collapsed: range.length === 0,\n        empty: range.length === 0 && line.length() <= 1,\n        format: this.quill.getFormat(range),\n        offset: offset,\n        prefix: prefixText,\n        suffix: suffixText\n      };\n      let prevented = bindings.some((binding) => {\n        if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;\n        if (binding.empty != null && binding.empty !== curContext.empty) return false;\n        if (binding.offset != null && binding.offset !== curContext.offset) return false;\n        if (Array.isArray(binding.format)) {\n          // any format is present\n          if (binding.format.every(function(name) {\n            return curContext.format[name] == null;\n          })) {\n            return false;\n          }\n        } else if (typeof binding.format === 'object') {\n          // all formats must match\n          if (!Object.keys(binding.format).every(function(name) {\n            if (binding.format[name] === true) return curContext.format[name] != null;\n            if (binding.format[name] === false) return curContext.format[name] == null;\n            return equal(binding.format[name], curContext.format[name]);\n          })) {\n            return false;\n          }\n        }\n        if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;\n        if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;\n        return binding.handler.call(this, range, curContext) !== true;\n      });\n      if (prevented) {\n        evt.preventDefault();\n      }\n    });\n  }\n}\n\nKeyboard.keys = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  ESCAPE: 27,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  DELETE: 46\n};\n\nKeyboard.DEFAULTS = {\n  bindings: {\n    'bold'      : makeFormatHandler('bold'),\n    'italic'    : makeFormatHandler('italic'),\n    'underline' : makeFormatHandler('underline'),\n    'indent': {\n      // highlight tab or tab at beginning of list, indent or blockquote\n      key: Keyboard.keys.TAB,\n      format: ['blockquote', 'indent', 'list'],\n      handler: function(range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '+1', Quill.sources.USER);\n      }\n    },\n    'outdent': {\n      key: Keyboard.keys.TAB,\n      shiftKey: true,\n      format: ['blockquote', 'indent', 'list'],\n      // highlight tab or tab at beginning of list, indent or blockquote\n      handler: function(range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '-1', Quill.sources.USER);\n      }\n    },\n    'outdent backspace': {\n      key: Keyboard.keys.BACKSPACE,\n      collapsed: true,\n      shiftKey: null,\n      metaKey: null,\n      ctrlKey: null,\n      altKey: null,\n      format: ['indent', 'list'],\n      offset: 0,\n      handler: function(range, context) {\n        if (context.format.indent != null) {\n          this.quill.format('indent', '-1', Quill.sources.USER);\n        } else if (context.format.list != null) {\n          this.quill.format('list', false, Quill.sources.USER);\n        }\n      }\n    },\n    'indent code-block': makeCodeBlockHandler(true),\n    'outdent code-block': makeCodeBlockHandler(false),\n    'remove tab': {\n      key: Keyboard.keys.TAB,\n      shiftKey: true,\n      collapsed: true,\n      prefix: /\\t$/,\n      handler: function(range) {\n        this.quill.deleteText(range.index - 1, 1, Quill.sources.USER);\n      }\n    },\n    'tab': {\n      key: Keyboard.keys.TAB,\n      handler: function(range) {\n        this.quill.history.cutoff();\n        let delta = new Delta().retain(range.index)\n                               .delete(range.length)\n                               .insert('\\t');\n        this.quill.updateContents(delta, Quill.sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);\n      }\n    },\n    'list empty enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['list'],\n      empty: true,\n      handler: function(range, context) {\n        this.quill.format('list', false, Quill.sources.USER);\n        if (context.format.indent) {\n          this.quill.format('indent', false, Quill.sources.USER);\n        }\n      }\n    },\n    'checklist enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: { list: 'checked' },\n      handler: function(range) {\n        let [line, offset] = this.quill.getLine(range.index);\n        let formats = extend({}, line.formats(), { list: 'checked' });\n        let delta = new Delta().retain(range.index)\n                               .insert('\\n', formats)\n                               .retain(line.length() - offset - 1)\n                               .retain(1, { list: 'unchecked' });\n        this.quill.updateContents(delta, Quill.sources.USER);\n        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'header enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['header'],\n      suffix: /^$/,\n      handler: function(range, context) {\n        let [line, offset] = this.quill.getLine(range.index);\n        let delta = new Delta().retain(range.index)\n                               .insert('\\n', context.format)\n                               .retain(line.length() - offset - 1)\n                               .retain(1, { header: null });\n        this.quill.updateContents(delta, Quill.sources.USER);\n        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'list autofill': {\n      key: ' ',\n      collapsed: true,\n      format: { list: false },\n      prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n      handler: function(range, context) {\n        let length = context.prefix.length;\n        let [line, offset] = this.quill.getLine(range.index);\n        if (offset > length) return true;\n        let value;\n        switch (context.prefix.trim()) {\n          case '[]': case '[ ]':\n            value = 'unchecked';\n            break;\n          case '[x]':\n            value = 'checked';\n            break;\n          case '-': case '*':\n            value = 'bullet';\n            break;\n          default:\n            value = 'ordered';\n        }\n        this.quill.insertText(range.index, ' ', Quill.sources.USER);\n        this.quill.history.cutoff();\n        let delta = new Delta().retain(range.index - offset)\n                               .delete(length + 1)\n                               .retain(line.length() - 2 - offset)\n                               .retain(1, { list: value });\n        this.quill.updateContents(delta, Quill.sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index - length, Quill.sources.SILENT);\n      }\n    },\n    'code exit': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['code-block'],\n      prefix: /\\n\\n$/,\n      suffix: /^\\s+$/,\n      handler: function(range) {\n        const [line, offset] = this.quill.getLine(range.index);\n        const delta = new Delta()\n          .retain(range.index + line.length() - offset - 2)\n          .retain(1, { 'code-block': null })\n          .delete(1);\n        this.quill.updateContents(delta, Quill.sources.USER);\n      }\n    },\n    'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),\n    'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),\n    'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),\n    'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)\n  }\n};\n\nfunction makeEmbedArrowHandler(key, shiftKey) {\n  const where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';\n  return {\n    key,\n    shiftKey,\n    altKey: null,\n    [where]: /^$/,\n    handler: function(range) {\n      let index = range.index;\n      if (key === Keyboard.keys.RIGHT) {\n        index += (range.length + 1);\n      }\n      const [leaf, ] = this.quill.getLeaf(index);\n      if (!(leaf instanceof Parchment.Embed)) return true;\n      if (key === Keyboard.keys.LEFT) {\n        if (shiftKey) {\n          this.quill.setSelection(range.index - 1, range.length + 1, Quill.sources.USER);\n        } else {\n          this.quill.setSelection(range.index - 1, Quill.sources.USER);\n        }\n      } else {\n        if (shiftKey) {\n          this.quill.setSelection(range.index, range.length + 1, Quill.sources.USER);\n        } else {\n          this.quill.setSelection(range.index + range.length + 1, Quill.sources.USER);\n        }\n      }\n      return false;\n    }\n  };\n}\n\n\nfunction handleBackspace(range, context) {\n  if (range.index === 0 || this.quill.getLength() <= 1) return;\n  let [line, ] = this.quill.getLine(range.index);\n  let formats = {};\n  if (context.offset === 0) {\n    let [prev, ] = this.quill.getLine(range.index - 1);\n    if (prev != null && prev.length() > 1) {\n      let curFormats = line.formats();\n      let prevFormats = this.quill.getFormat(range.index-1, 1);\n      formats = DeltaOp.attributes.diff(curFormats, prevFormats) || {};\n    }\n  }\n  // Check for astral symbols\n  let length = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(context.prefix) ? 2 : 1;\n  this.quill.deleteText(range.index-length, length, Quill.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index-length, length, formats, Quill.sources.USER);\n  }\n  this.quill.focus();\n}\n\nfunction handleDelete(range, context) {\n  // Check for astral symbols\n  let length = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(context.suffix) ? 2 : 1;\n  if (range.index >= this.quill.getLength() - length) return;\n  let formats = {}, nextLength = 0;\n  let [line, ] = this.quill.getLine(range.index);\n  if (context.offset >= line.length() - 1) {\n    let [next, ] = this.quill.getLine(range.index + 1);\n    if (next) {\n      let curFormats = line.formats();\n      let nextFormats = this.quill.getFormat(range.index, 1);\n      formats = DeltaOp.attributes.diff(curFormats, nextFormats) || {};\n      nextLength = next.length();\n    }\n  }\n  this.quill.deleteText(range.index, length, Quill.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index + nextLength - 1, length, formats, Quill.sources.USER);\n  }\n}\n\nfunction handleDeleteRange(range) {\n  let lines = this.quill.getLines(range);\n  let formats = {};\n  if (lines.length > 1) {\n    let firstFormats = lines[0].formats();\n    let lastFormats = lines[lines.length - 1].formats();\n    formats = DeltaOp.attributes.diff(lastFormats, firstFormats) || {};\n  }\n  this.quill.deleteText(range, Quill.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index, 1, formats, Quill.sources.USER);\n  }\n  this.quill.setSelection(range.index, Quill.sources.SILENT);\n  this.quill.focus();\n}\n\nfunction handleEnter(range, context) {\n  if (range.length > 0) {\n    this.quill.scroll.deleteAt(range.index, range.length);  // So we do not trigger text-change\n  }\n  let lineFormats = Object.keys(context.format).reduce(function(lineFormats, format) {\n    if (Parchment.query(format, Parchment.Scope.BLOCK) && !Array.isArray(context.format[format])) {\n      lineFormats[format] = context.format[format];\n    }\n    return lineFormats;\n  }, {});\n  this.quill.insertText(range.index, '\\n', lineFormats, Quill.sources.USER);\n  // Earlier scroll.deleteAt might have messed up our selection,\n  // so insertText's built in selection preservation is not reliable\n  this.quill.setSelection(range.index + 1, Quill.sources.SILENT);\n  this.quill.focus();\n  Object.keys(context.format).forEach((name) => {\n    if (lineFormats[name] != null) return;\n    if (Array.isArray(context.format[name])) return;\n    if (name === 'link') return;\n    this.quill.format(name, context.format[name], Quill.sources.USER);\n  });\n}\n\nfunction makeCodeBlockHandler(indent) {\n  return {\n    key: Keyboard.keys.TAB,\n    shiftKey: !indent,\n    format: {'code-block': true },\n    handler: function(range) {\n      let CodeBlock = Parchment.query('code-block');\n      let index = range.index, length = range.length;\n      let [block, offset] = this.quill.scroll.descendant(CodeBlock, index);\n      if (block == null) return;\n      let scrollIndex = this.quill.getIndex(block);\n      let start = block.newlineIndex(offset, true) + 1;\n      let end = block.newlineIndex(scrollIndex + offset + length);\n      let lines = block.domNode.textContent.slice(start, end).split('\\n');\n      offset = 0;\n      lines.forEach((line, i) => {\n        if (indent) {\n          block.insertAt(start + offset, CodeBlock.TAB);\n          offset += CodeBlock.TAB.length;\n          if (i === 0) {\n            index += CodeBlock.TAB.length;\n          } else {\n            length += CodeBlock.TAB.length;\n          }\n        } else if (line.startsWith(CodeBlock.TAB)) {\n          block.deleteAt(start + offset, CodeBlock.TAB.length);\n          offset -= CodeBlock.TAB.length;\n          if (i === 0) {\n            index -= CodeBlock.TAB.length;\n          } else {\n            length -= CodeBlock.TAB.length;\n          }\n        }\n        offset += line.length + 1;\n      });\n      this.quill.update(Quill.sources.USER);\n      this.quill.setSelection(index, length, Quill.sources.SILENT);\n    }\n  };\n}\n\nfunction makeFormatHandler(format) {\n  return {\n    key: format[0].toUpperCase(),\n    shortKey: true,\n    handler: function(range, context) {\n      this.quill.format(format, !context.format[format], Quill.sources.USER);\n    }\n  };\n}\n\nfunction normalize(binding) {\n  if (typeof binding === 'string' || typeof binding === 'number') {\n    return normalize({ key: binding });\n  }\n  if (typeof binding === 'object') {\n    binding = clone(binding, false);\n  }\n  if (typeof binding.key === 'string') {\n    if (Keyboard.keys[binding.key.toUpperCase()] != null) {\n      binding.key = Keyboard.keys[binding.key.toUpperCase()];\n    } else if (binding.key.length === 1) {\n      binding.key = binding.key.toUpperCase().charCodeAt(0);\n    } else {\n      return null;\n    }\n  }\n  if (binding.shortKey) {\n    binding[SHORTKEY] = binding.shortKey;\n    delete binding.shortKey;\n  }\n  return binding;\n}\n\n\nexport { Keyboard as default, SHORTKEY };\n"]},"metadata":{},"sourceType":"module"}